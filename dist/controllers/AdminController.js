"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.adminController = exports.getDashboardStats = void 0;
exports.sendNotification = sendNotification;
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const connection_1 = __importDefault(require("../database/connection"));
const cloudinary_1 = __importStar(require("../config/cloudinary"));
const env_1 = require("../config/env");
const notificationService_1 = require("../services/notificationService");
const pushNotificationService_1 = require("../services/pushNotificationService");
const priceDropNotificationService_1 = require("../services/priceDropNotificationService");
const userNotificationService_1 = require("../services/userNotificationService");
const address_1 = require("../utils/address");
const creci_1 = require("../utils/creci");
const propertyTypes_1 = require("../utils/propertyTypes");
const jwtSecret = (0, env_1.requireEnv)('JWT_SECRET');
const STATUS_MAP = {
    pendingapproval: 'pending_approval',
    pendente: 'pending_approval',
    pending: 'pending_approval',
    aprovado: 'approved',
    aprovada: 'approved',
    approved: 'approved',
    rejeitado: 'rejected',
    rejeitada: 'rejected',
    rejected: 'rejected',
    alugado: 'rented',
    alugada: 'rented',
    rented: 'rented',
    vendido: 'sold',
    vendida: 'sold',
    sold: 'sold',
};
const ALLOWED_STATUS = new Set([
    'pending_approval',
    'approved',
    'rejected',
    'rented',
    'sold',
]);
const PURPOSE_MAP = {
    venda: 'Venda',
    comprar: 'Venda',
    aluguel: 'Aluguel',
    alugar: 'Aluguel',
    vendaealuguel: 'Venda e Aluguel',
    vendaaluguel: 'Venda e Aluguel',
};
const ALLOWED_PURPOSES = new Set(['Venda', 'Aluguel', 'Venda e Aluguel']);
const MAX_IMAGES_PER_PROPERTY = 20;
const IMAGE_UPLOAD_CONCURRENCY = 4;
const DIRECT_UPLOAD_IMAGE_MAX_BYTES = 15 * 1024 * 1024;
const DIRECT_UPLOAD_VIDEO_MAX_BYTES = 100 * 1024 * 1024;
const CLOUDINARY_IMAGE_ALLOWED_FORMATS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'heic', 'heif', 'svg'];
const CLOUDINARY_VIDEO_ALLOWED_FORMATS = ['mp4', 'mov', 'avi', 'webm', '3gp'];
function normalizeStatus(value) {
    if (typeof value !== 'string') {
        return null;
    }
    const normalized = value
        .normalize('NFD')
        .replace(/[^\p{L}0-9]/gu, '')
        .toLowerCase();
    const status = STATUS_MAP[normalized];
    if (!status || !ALLOWED_STATUS.has(status)) {
        return null;
    }
    return status;
}
function normalizePurpose(value) {
    if (typeof value !== 'string') {
        return null;
    }
    const normalized = value
        .normalize('NFD')
        .replace(/[^\p{L}0-9]/gu, '')
        .toLowerCase();
    const mapped = PURPOSE_MAP[normalized];
    if (!mapped || !ALLOWED_PURPOSES.has(mapped)) {
        return null;
    }
    return mapped;
}
function parseDecimal(value) {
    if (value === undefined || value === null || value === '') {
        return null;
    }
    const parsed = Number(value);
    if (!Number.isFinite(parsed)) {
        return null;
    }
    return parsed;
}
function parseInteger(value) {
    if (value === undefined || value === null || value === '') {
        return null;
    }
    const parsed = Number(value);
    if (!Number.isFinite(parsed)) {
        return null;
    }
    return Math.trunc(parsed);
}
function parseBoolean(value) {
    if (typeof value === 'boolean') {
        return value ? 1 : 0;
    }
    if (typeof value === 'number') {
        return value === 0 ? 0 : 1;
    }
    if (typeof value === 'string') {
        const normalized = value.trim().toLowerCase();
        return ['1', 'true', 'yes', 'sim', 'on'].includes(normalized) ? 1 : 0;
    }
    return 0;
}
function parsePromotionPercentage(value) {
    if (value === undefined || value === null || value === '') {
        return null;
    }
    const parsed = Number(value);
    if (!Number.isFinite(parsed) || parsed <= 0 || parsed > 100) {
        throw new Error('Percentual de promocao invalido. Use valor entre 0 e 100.');
    }
    return Number(parsed.toFixed(2));
}
function parsePromotionDateTime(value) {
    if (value === undefined || value === null || value === '') {
        return null;
    }
    const parsed = new Date(String(value));
    if (Number.isNaN(parsed.getTime())) {
        throw new Error('Data de promocao invalida.');
    }
    return parsed.toISOString().slice(0, 19).replace('T', ' ');
}
function normalizeTipoLote(value) {
    if (value === undefined || value === null) {
        return null;
    }
    const normalized = String(value).trim().toLowerCase();
    if (!normalized) {
        return null;
    }
    if (normalized === 'meio') {
        return 'meio';
    }
    if (normalized === 'inteiro') {
        return 'inteiro';
    }
    return null;
}
function stringOrNull(value) {
    if (value === undefined || value === null) {
        return null;
    }
    const textual = String(value).trim();
    return textual.length > 0 ? textual : null;
}
const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
function normalizeDigits(value) {
    if (value === undefined || value === null) {
        return '';
    }
    return String(value).replace(/\D/g, '');
}
function isValidEmail(value) {
    if (typeof value !== 'string')
        return false;
    return EMAIL_REGEX.test(value.trim());
}
function normalizePhone(value) {
    return normalizeDigits(value).slice(0, 11);
}
function hasValidPhone(value) {
    return normalizePhone(value).length === 11;
}
function parseStringArray(value) {
    if (Array.isArray(value)) {
        return value.map((entry) => String(entry).trim()).filter(Boolean);
    }
    if (typeof value !== 'string') {
        return [];
    }
    const trimmed = value.trim();
    if (!trimmed) {
        return [];
    }
    if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmed);
            if (Array.isArray(parsed)) {
                return parsed.map((entry) => String(entry).trim()).filter(Boolean);
            }
        }
        catch {
            return [];
        }
    }
    return [trimmed];
}
function parseImageUrlsInput(body) {
    const fromArrayField = parseStringArray(body.image_urls);
    const fromBracketField = parseStringArray(body['image_urls[]']);
    return Array.from(new Set([...fromArrayField, ...fromBracketField]));
}
function isAllowedCloudinaryMediaUrl(urlValue, expectedFolder) {
    try {
        const parsed = new URL(urlValue);
        if (parsed.protocol !== 'https:' || parsed.hostname !== 'res.cloudinary.com') {
            return false;
        }
        const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
        if (!cloudName)
            return false;
        if (!parsed.pathname.startsWith(`/${cloudName}/`)) {
            return false;
        }
        return parsed.pathname.includes(`/${expectedFolder}/`);
    }
    catch {
        return false;
    }
}
async function uploadImagesWithConcurrency(files, folder, concurrency = IMAGE_UPLOAD_CONCURRENCY) {
    if (files.length === 0) {
        return [];
    }
    const results = new Array(files.length);
    let nextIndex = 0;
    const workers = Array.from({ length: Math.min(concurrency, files.length) }, async () => {
        while (true) {
            const currentIndex = nextIndex;
            nextIndex += 1;
            if (currentIndex >= files.length) {
                break;
            }
            const uploaded = await (0, cloudinary_1.uploadToCloudinary)(files[currentIndex], folder);
            results[currentIndex] = uploaded.url;
        }
    });
    await Promise.all(workers);
    return results;
}
function toNullableNumber(value) {
    if (value === undefined || value === null || value === '') {
        return null;
    }
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
}
function mapAdminProperty(row) {
    const images = Array.isArray(row.images)
        ? row.images
        : row.images
            ? String(row.images)
                .split(';')
                .map((item) => item.trim())
                .filter(Boolean)
                .map((pair) => {
                const [id, url] = pair.split('|');
                const numId = Number(id);
                return { id: Number.isFinite(numId) ? numId : null, url };
            })
                .filter((item) => item.id !== null && item.url)
            : [];
    return {
        id: row.id,
        broker_id: row.broker_id ?? null,
        owner_id: row.owner_id ?? null,
        owner_name: row.owner_name ?? null,
        owner_phone: row.owner_phone ?? null,
        code: row.code ?? null,
        title: row.title,
        description: row.description ?? null,
        type: row.type ?? '',
        purpose: row.purpose ?? null,
        status: row.status,
        is_promoted: parseBoolean(row.is_promoted),
        promotion_percentage: toNullableNumber(row.promotion_percentage),
        promotional_rent_percentage: toNullableNumber(row.promotional_rent_percentage),
        promotion_start: row.promotion_start ? String(row.promotion_start) : null,
        promotion_end: row.promotion_end ? String(row.promotion_end) : null,
        price: toNullableNumber(row.price) ?? 0,
        price_sale: toNullableNumber(row.price_sale),
        price_rent: toNullableNumber(row.price_rent),
        promotion_price: toNullableNumber(row.promotion_price),
        promotional_rent_price: toNullableNumber(row.promotional_rent_price),
        promotionalPrice: toNullableNumber(row.promotion_price),
        promotionalRentPrice: toNullableNumber(row.promotional_rent_price),
        promotionalRentPercentage: toNullableNumber(row.promotional_rent_percentage),
        address: row.address ?? null,
        cep: row.cep ?? null,
        quadra: row.quadra ?? null,
        lote: row.lote ?? null,
        numero: row.numero ?? null,
        bairro: row.bairro ?? null,
        complemento: row.complemento ?? null,
        tipo_lote: row.tipo_lote ?? null,
        city: row.city ?? null,
        state: row.state ?? null,
        bedrooms: toNullableNumber(row.bedrooms),
        bathrooms: toNullableNumber(row.bathrooms),
        area_construida: toNullableNumber(row.area_construida),
        area_terreno: toNullableNumber(row.area_terreno),
        garage_spots: toNullableNumber(row.garage_spots),
        valor_condominio: toNullableNumber(row.valor_condominio),
        valor_iptu: toNullableNumber(row.valor_iptu),
        video_url: row.video_url ?? null,
        has_wifi: parseBoolean(row.has_wifi),
        tem_piscina: parseBoolean(row.tem_piscina),
        tem_energia_solar: parseBoolean(row.tem_energia_solar),
        tem_automacao: parseBoolean(row.tem_automacao),
        tem_ar_condicionado: parseBoolean(row.tem_ar_condicionado),
        eh_mobiliada: parseBoolean(row.eh_mobiliada),
        images,
        broker_name: row.broker_name ?? null,
        broker_phone: row.broker_phone ?? null,
        broker_status: row.broker_status ?? null,
        broker_creci: row.broker_creci ?? null,
        created_at: row.created_at ? String(row.created_at) : null,
        updated_at: row.updated_at ? String(row.updated_at) : null,
    };
}
const NEGOTIATION_INTERNAL_STATUSES = new Set([
    'PROPOSAL_DRAFT',
    'PROPOSAL_SENT',
    'IN_NEGOTIATION',
    'DOCUMENTATION_PHASE',
    'CONTRACT_DRAFTING',
    'AWAITING_SIGNATURES',
    'SOLD',
    'RENTED',
    'CANCELLED',
]);
function parseNegotiationStatusFilter(value) {
    if (typeof value !== 'string') {
        return null;
    }
    const normalized = value.trim().toUpperCase();
    if (!normalized) {
        return null;
    }
    if (normalized === 'UNDER_REVIEW' || normalized === 'APPROVED') {
        return normalized;
    }
    if (NEGOTIATION_INTERNAL_STATUSES.has(normalized)) {
        return normalized;
    }
    return null;
}
function buildNegotiationStatusClause(statusFilter) {
    if (!statusFilter) {
        return { clause: '', params: [] };
    }
    if (statusFilter === 'UNDER_REVIEW') {
        return {
            clause: " AND (n.status = 'DOCUMENTATION_PHASE' OR (n.status = 'IN_NEGOTIATION' AND COALESCE(p.status, '') <> 'negociacao'))",
            params: [],
        };
    }
    if (statusFilter === 'APPROVED' || statusFilter === 'IN_NEGOTIATION') {
        return {
            clause: " AND n.status = 'IN_NEGOTIATION' AND COALESCE(p.status, '') = 'negociacao'",
            params: [],
        };
    }
    return {
        clause: ' AND n.status = ?',
        params: [statusFilter],
    };
}
function toNegotiationMoney(value) {
    const parsed = Number(value);
    if (!Number.isFinite(parsed)) {
        return 0;
    }
    return Number(parsed.toFixed(2));
}
function toAdminNegotiationStatus(row) {
    const negotiationStatus = String(row.negotiation_status ?? '').toUpperCase();
    const propertyStatus = String(row.property_status ?? '').toLowerCase();
    if (negotiationStatus === 'DOCUMENTATION_PHASE' ||
        (negotiationStatus === 'IN_NEGOTIATION' && propertyStatus !== 'negociacao')) {
        return 'UNDER_REVIEW';
    }
    if (negotiationStatus === 'IN_NEGOTIATION' && propertyStatus === 'negociacao') {
        return 'APPROVED';
    }
    return negotiationStatus;
}
function mapAdminNegotiation(row) {
    return {
        id: row.id,
        status: toAdminNegotiationStatus(row),
        internalStatus: String(row.negotiation_status ?? '').toUpperCase(),
        propertyId: Number(row.property_id),
        propertyCode: row.property_code ?? null,
        propertyTitle: row.property_title ?? null,
        propertyAddress: row.property_address ?? null,
        brokerName: row.capturing_broker_name ?? row.selling_broker_name ?? null,
        capturingBrokerName: row.capturing_broker_name ?? null,
        sellingBrokerName: row.selling_broker_name ?? null,
        clientName: row.client_name ?? null,
        clientCpf: row.client_cpf ?? null,
        value: toNullableNumber(row.final_value),
        validityDate: row.proposal_validity_date ? String(row.proposal_validity_date) : null,
        payment: {
            dinheiro: toNegotiationMoney(row.payment_dinheiro),
            permuta: toNegotiationMoney(row.payment_permuta),
            financiamento: toNegotiationMoney(row.payment_financiamento),
            outros: toNegotiationMoney(row.payment_outros),
        },
        updatedAt: row.last_event_at ? String(row.last_event_at) : null,
        approvedAt: row.approved_at ? String(row.approved_at) : null,
        signedDocumentId: row.signed_document_id != null ? Number(row.signed_document_id) : null,
    };
}
function resolveNegotiationPropertyTitle(value) {
    const title = String(value ?? '').trim();
    return title.length > 0 ? title : 'Imóvel sem título';
}
async function fetchPropertyOwner(propertyId) {
    const [rows] = await connection_1.default.query('SELECT broker_id, owner_id, title FROM properties WHERE id = ?', [propertyId]);
    if (!rows || rows.length === 0) {
        return { ownerId: null, title: '' };
    }
    const row = rows[0];
    const brokerId = row.broker_id != null ? Number(row.broker_id) : null;
    const ownerId = row.owner_id != null ? Number(row.owner_id) : null;
    const title = typeof row.title === 'string' ? row.title : '';
    const resolvedOwner = Number.isFinite(brokerId ?? NaN) ? brokerId : Number.isFinite(ownerId ?? NaN) ? ownerId : null;
    return { ownerId: resolvedOwner, title };
}
class AdminController {
    async login(req, res) {
        const { email, password } = req.body;
        if (!email || !password) {
            return res.status(400).json({ error: 'Email e senha sao obrigatorios.' });
        }
        try {
            const [rows] = await connection_1.default.query('SELECT id, name, email, password_hash FROM admins WHERE email = ?', [email]);
            if (rows.length === 0) {
                return res.status(401).json({ error: 'Credenciais invalidas.' });
            }
            const admin = rows[0];
            const isPasswordCorrect = await bcryptjs_1.default.compare(password, String(admin.password_hash));
            if (!isPasswordCorrect) {
                return res.status(401).json({ error: 'Credenciais invalidas.' });
            }
            const token = jsonwebtoken_1.default.sign({ id: admin.id, role: 'admin' }, jwtSecret, { expiresIn: '1d' });
            delete admin.password_hash;
            return res.status(200).json({ admin, token });
        }
        catch (error) {
            console.error('Erro no login do admin:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async listNegotiations(req, res) {
        try {
            const page = Math.max(parseInt(String(req.query.page ?? '1'), 10) || 1, 1);
            const limit = Math.min(Math.max(parseInt(String(req.query.limit ?? '20'), 10) || 20, 1), 100);
            const offset = (page - 1) * limit;
            const statusFilter = parseNegotiationStatusFilter(req.query.status);
            const { clause, params } = buildNegotiationStatusClause(statusFilter);
            const [countRows] = await connection_1.default.query(`
          SELECT COUNT(*) AS total
          FROM negotiations n
          JOIN properties p ON p.id = n.property_id
          WHERE 1 = 1
          ${clause}
        `, params);
            const total = Number(countRows[0]?.total ?? 0);
            const [rows] = await connection_1.default.query(`
          SELECT
            n.id,
            n.status AS negotiation_status,
            n.property_id,
            p.status AS property_status,
            p.code AS property_code,
            p.title AS property_title,
            CONCAT_WS(', ', p.address, p.numero, p.bairro, p.city, p.state) AS property_address,
            n.final_value,
            n.proposal_validity_date,
            capture_user.name AS capturing_broker_name,
            seller_user.name AS selling_broker_name,
            COALESCE(
              NULLIF(n.client_name, ''),
              JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.clientName')),
              JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.client_name')),
              JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.clientName')),
              JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.client_name'))
            ) AS client_name,
            COALESCE(
              NULLIF(n.client_cpf, ''),
              JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.clientCpf')),
              JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.client_cpf')),
              JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.clientCpf')),
              JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.client_cpf'))
            ) AS client_cpf,
            COALESCE(
              CAST(JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.dinheiro')) AS DECIMAL(12,2)),
              CAST(JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.cash')) AS DECIMAL(12,2)),
              0
            ) AS payment_dinheiro,
            COALESCE(
              CAST(JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.permuta')) AS DECIMAL(12,2)),
              CAST(JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.trade_in')) AS DECIMAL(12,2)),
              CAST(JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.tradeIn')) AS DECIMAL(12,2)),
              0
            ) AS payment_permuta,
            COALESCE(
              CAST(JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.financiamento')) AS DECIMAL(12,2)),
              CAST(JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.financing')) AS DECIMAL(12,2)),
              0
            ) AS payment_financiamento,
            COALESCE(
              CAST(JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.outros')) AS DECIMAL(12,2)),
              CAST(JSON_UNQUOTE(JSON_EXTRACT(n.payment_details, '$.details.others')) AS DECIMAL(12,2)),
              0
            ) AS payment_outros,
            latest_history.created_at AS last_event_at,
            approved_history.approved_at AS approved_at,
            signed_doc.id AS signed_document_id
          FROM negotiations n
          JOIN properties p ON p.id = n.property_id
          LEFT JOIN users capture_user ON capture_user.id = n.capturing_broker_id
          LEFT JOIN users seller_user ON seller_user.id = n.selling_broker_id
          LEFT JOIN (
            SELECT ranked.negotiation_id, ranked.created_at
            FROM (
              SELECT
                h.negotiation_id,
                h.created_at,
                ROW_NUMBER() OVER (
                  PARTITION BY h.negotiation_id
                  ORDER BY h.created_at DESC
                ) AS rn
              FROM negotiation_history h
            ) ranked
            WHERE ranked.rn = 1
          ) latest_history ON latest_history.negotiation_id = n.id
          LEFT JOIN (
            SELECT
              h.negotiation_id,
              MAX(h.created_at) AS approved_at
            FROM negotiation_history h
            WHERE h.to_status = 'IN_NEGOTIATION'
            GROUP BY h.negotiation_id
          ) approved_history ON approved_history.negotiation_id = n.id
          LEFT JOIN (
            SELECT ranked.negotiation_id, ranked.id
            FROM (
              SELECT
                d.negotiation_id,
                d.id,
                ROW_NUMBER() OVER (
                  PARTITION BY d.negotiation_id
                  ORDER BY d.created_at DESC, d.id DESC
                ) AS rn
              FROM negotiation_documents d
              WHERE d.type = 'other'
            ) ranked
            WHERE ranked.rn = 1
          ) signed_doc ON signed_doc.negotiation_id = n.id
          WHERE 1 = 1
          ${clause}
          ORDER BY COALESCE(latest_history.created_at, approved_history.approved_at) DESC, n.id DESC
          LIMIT ? OFFSET ?
        `, [...params, limit, offset]);
            return res.status(200).json({
                data: rows.map(mapAdminNegotiation),
                page,
                limit,
                total,
            });
        }
        catch (error) {
            console.error('Erro ao listar negociações para admin:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async approveNegotiation(req, res) {
        const negotiationId = String(req.params.id ?? '').trim();
        const actorId = Number(req.userId);
        if (!negotiationId) {
            return res.status(400).json({ error: 'ID de negociação inválido.' });
        }
        if (!actorId) {
            return res.status(401).json({ error: 'Administrador não autenticado.' });
        }
        const tx = await connection_1.default.getConnection();
        try {
            await tx.beginTransaction();
            const [rows] = await tx.query(`
          SELECT
            n.id,
            n.status,
            n.property_id,
            n.capturing_broker_id,
            p.title AS property_title,
            p.code AS property_code,
            CONCAT_WS(', ', p.address, p.numero, p.bairro, p.city, p.state) AS property_address,
            p.status AS property_status,
            p.lifecycle_status
          FROM negotiations n
          JOIN properties p ON p.id = n.property_id
          WHERE n.id = ?
          LIMIT 1
          FOR UPDATE
        `, [negotiationId]);
            if (!rows.length) {
                await tx.rollback();
                return res.status(404).json({ error: 'Negociação não encontrada.' });
            }
            const negotiation = rows[0];
            const currentStatus = String(negotiation.status ?? '').toUpperCase();
            if (currentStatus === 'CANCELLED' || currentStatus === 'SOLD' || currentStatus === 'RENTED') {
                await tx.rollback();
                return res.status(400).json({ error: 'Não é possível aprovar uma negociação encerrada.' });
            }
            await tx.query(`
          UPDATE negotiations
          SET status = 'IN_NEGOTIATION', version = version + 1
          WHERE id = ?
        `, [negotiationId]);
            await tx.query(`
          INSERT INTO negotiation_history (
            id,
            negotiation_id,
            from_status,
            to_status,
            actor_id,
            metadata_json,
            created_at
          ) VALUES (UUID(), ?, ?, 'IN_NEGOTIATION', ?, CAST(? AS JSON), CURRENT_TIMESTAMP)
        `, [
                negotiationId,
                currentStatus,
                actorId,
                JSON.stringify({
                    action: 'admin_approved',
                }),
            ]);
            await tx.query(`
          UPDATE properties
          SET status = 'negociacao', visibility = 'HIDDEN', lifecycle_status = 'AVAILABLE'
          WHERE id = ?
        `, [negotiation.property_id]);
            const [existingContractRows] = await tx.query(`
          SELECT id
          FROM contracts
          WHERE negotiation_id = ?
          LIMIT 1
          FOR UPDATE
        `, [negotiationId]);
            if (existingContractRows.length === 0) {
                await tx.query(`
            INSERT INTO contracts (
              id,
              negotiation_id,
              property_id,
              status,
              seller_approval_status,
              buyer_approval_status,
              created_at,
              updated_at
            ) VALUES (
              UUID(),
              ?,
              ?,
              'AWAITING_DOCS',
              'PENDING',
              'PENDING',
              CURRENT_TIMESTAMP,
              CURRENT_TIMESTAMP
            )
          `, [negotiationId, negotiation.property_id]);
            }
            await tx.commit();
            const recipientBrokerId = Number(negotiation.capturing_broker_id ?? 0);
            if (Number.isFinite(recipientBrokerId) && recipientBrokerId > 0) {
                const propertyTitle = resolveNegotiationPropertyTitle(negotiation.property_title);
                try {
                    await (0, notificationService_1.createUserNotification)({
                        type: 'negotiation',
                        title: 'Proposta Aprovada!',
                        message: `Sua proposta para o imóvel ${propertyTitle} foi aprovada pela administração. O imóvel agora está Em Negociação.`,
                        recipientId: recipientBrokerId,
                        relatedEntityId: Number(negotiation.property_id),
                        metadata: {
                            negotiationId,
                            propertyId: Number(negotiation.property_id),
                            status: 'APPROVED',
                        },
                    });
                }
                catch (notifyError) {
                    console.error('Erro ao notificar corretor sobre aprovação da proposta:', notifyError);
                }
            }
            return res.status(200).json({
                message: 'Negociação aprovada com sucesso.',
                id: negotiationId,
                status: 'APPROVED',
                internalStatus: 'IN_NEGOTIATION',
            });
        }
        catch (error) {
            await tx.rollback();
            console.error('Erro ao aprovar negociação:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
        finally {
            tx.release();
        }
    }
    async rejectNegotiation(req, res) {
        const negotiationId = String(req.params.id ?? '').trim();
        const actorId = Number(req.userId);
        const reason = String(req.body?.reason ?? '').trim();
        if (!negotiationId) {
            return res.status(400).json({ error: 'ID de negociação inválido.' });
        }
        if (!actorId) {
            return res.status(401).json({ error: 'Administrador não autenticado.' });
        }
        if (!reason) {
            return res.status(400).json({ error: 'Motivo da rejeição é obrigatório.' });
        }
        const tx = await connection_1.default.getConnection();
        try {
            await tx.beginTransaction();
            const [rows] = await tx.query(`
          SELECT
            n.id,
            n.status,
            n.property_id,
            n.capturing_broker_id,
            p.title AS property_title,
            p.code AS property_code,
            CONCAT_WS(', ', p.address, p.numero, p.bairro, p.city, p.state) AS property_address,
            p.status AS property_status,
            p.lifecycle_status
          FROM negotiations n
          JOIN properties p ON p.id = n.property_id
          WHERE n.id = ?
          LIMIT 1
          FOR UPDATE
        `, [negotiationId]);
            if (!rows.length) {
                await tx.rollback();
                return res.status(404).json({ error: 'Negociação não encontrada.' });
            }
            const negotiation = rows[0];
            const currentStatus = String(negotiation.status ?? '').toUpperCase();
            if (currentStatus === 'SOLD' || currentStatus === 'RENTED') {
                await tx.rollback();
                return res.status(400).json({ error: 'Negociação já finalizada, rejeição não permitida.' });
            }
            await tx.query(`
          UPDATE negotiations
          SET status = 'CANCELLED', version = version + 1
          WHERE id = ?
        `, [negotiationId]);
            await tx.query(`
          INSERT INTO negotiation_history (
            id,
            negotiation_id,
            from_status,
            to_status,
            actor_id,
            metadata_json,
            created_at
          ) VALUES (UUID(), ?, ?, 'CANCELLED', ?, CAST(? AS JSON), CURRENT_TIMESTAMP)
        `, [
                negotiationId,
                currentStatus,
                actorId,
                JSON.stringify({
                    action: 'admin_rejected',
                    reason,
                }),
            ]);
            await tx.query(`
          UPDATE properties
          SET status = 'approved', visibility = 'PUBLIC', lifecycle_status = 'AVAILABLE'
          WHERE id = ?
            AND lifecycle_status NOT IN ('SOLD', 'RENTED')
            AND status NOT IN ('sold', 'rented')
        `, [negotiation.property_id]);
            await tx.commit();
            const recipientBrokerId = Number(negotiation.capturing_broker_id ?? 0);
            if (Number.isFinite(recipientBrokerId) && recipientBrokerId > 0) {
                const propertyTitle = resolveNegotiationPropertyTitle(negotiation.property_title);
                try {
                    await (0, notificationService_1.createUserNotification)({
                        type: 'negotiation',
                        title: 'Proposta Rejeitada.',
                        message: `Sua proposta para o imóvel ${propertyTitle} foi rejeitada. Motivo: ${reason}.`,
                        recipientId: recipientBrokerId,
                        relatedEntityId: Number(negotiation.property_id),
                        metadata: {
                            negotiationId,
                            propertyId: Number(negotiation.property_id),
                            reason,
                            status: 'REJECTED',
                        },
                    });
                }
                catch (notifyError) {
                    console.error('Erro ao notificar corretor sobre rejeição da proposta:', notifyError);
                }
            }
            return res.status(200).json({
                message: 'Negociação rejeitada e imóvel devolvido para disponível.',
                id: negotiationId,
                status: 'REJECTED',
            });
        }
        catch (error) {
            await tx.rollback();
            console.error('Erro ao rejeitar negociação:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
        finally {
            tx.release();
        }
    }
    async cancelNegotiation(req, res) {
        const negotiationId = String(req.params.id ?? '').trim();
        const actorId = Number(req.userId);
        const reason = String(req.body?.reason ?? '').trim();
        if (!negotiationId) {
            return res.status(400).json({ error: 'ID de negociação inválido.' });
        }
        if (!actorId) {
            return res.status(401).json({ error: 'Administrador não autenticado.' });
        }
        if (reason.length < 5) {
            return res.status(400).json({ error: 'Motivo obrigatório com no mínimo 5 caracteres.' });
        }
        const tx = await connection_1.default.getConnection();
        try {
            await tx.beginTransaction();
            const [rows] = await tx.query(`
          SELECT
            n.id,
            n.status,
            n.property_id,
            n.capturing_broker_id,
            p.title AS property_title,
            p.code AS property_code,
            CONCAT_WS(', ', p.address, p.numero, p.bairro, p.city, p.state) AS property_address,
            p.status AS property_status,
            p.lifecycle_status
          FROM negotiations n
          JOIN properties p ON p.id = n.property_id
          WHERE n.id = ?
          LIMIT 1
          FOR UPDATE
        `, [negotiationId]);
            if (!rows.length) {
                await tx.rollback();
                return res.status(404).json({ error: 'Negociação não encontrada.' });
            }
            const negotiation = rows[0];
            const currentStatus = String(negotiation.status ?? '').toUpperCase();
            const propertyStatus = String(negotiation.property_status ?? '').toLowerCase();
            if (currentStatus === 'SOLD' || currentStatus === 'RENTED') {
                await tx.rollback();
                return res.status(400).json({ error: 'Negociação já finalizada, cancelamento não permitido.' });
            }
            if (currentStatus !== 'IN_NEGOTIATION' || propertyStatus !== 'negociacao') {
                await tx.rollback();
                return res.status(400).json({ error: 'Somente negociações em andamento podem ser canceladas.' });
            }
            await tx.query(`
          UPDATE negotiations
          SET status = 'CANCELLED', version = version + 1
          WHERE id = ?
        `, [negotiationId]);
            await tx.query(`
          INSERT INTO negotiation_history (
            id,
            negotiation_id,
            from_status,
            to_status,
            actor_id,
            metadata_json,
            created_at
          ) VALUES (UUID(), ?, ?, 'CANCELLED', ?, CAST(? AS JSON), CURRENT_TIMESTAMP)
        `, [
                negotiationId,
                currentStatus,
                actorId,
                JSON.stringify({
                    action: 'admin_cancelled',
                    reason,
                }),
            ]);
            await tx.query(`
          UPDATE properties
          SET status = 'approved', visibility = 'PUBLIC', lifecycle_status = 'AVAILABLE'
          WHERE id = ?
            AND lifecycle_status NOT IN ('SOLD', 'RENTED')
            AND status NOT IN ('sold', 'rented')
        `, [negotiation.property_id]);
            await tx.commit();
            const recipientBrokerId = Number(negotiation.capturing_broker_id ?? 0);
            if (Number.isFinite(recipientBrokerId) && recipientBrokerId > 0) {
                const propertyTitle = resolveNegotiationPropertyTitle(negotiation.property_title);
                const brokerMessage = `A negociação para o imóvel ${propertyTitle} foi cancelada. O imóvel voltou para a vitrine. Motivo: ${reason}.`;
                try {
                    await (0, notificationService_1.createUserNotification)({
                        type: 'negotiation',
                        title: 'Negociação Cancelada ⚠️',
                        message: brokerMessage,
                        recipientId: recipientBrokerId,
                        relatedEntityId: Number(negotiation.property_id),
                        recipientRole: 'broker',
                        metadata: {
                            negotiationId,
                            propertyId: Number(negotiation.property_id),
                            reason,
                            status: 'CANCELLED',
                        },
                    });
                    await (0, pushNotificationService_1.sendPushNotifications)({
                        message: brokerMessage,
                        recipientIds: [recipientBrokerId],
                        relatedEntityType: 'negotiation',
                        relatedEntityId: Number(negotiation.property_id),
                    });
                }
                catch (notifyError) {
                    console.error('Erro ao notificar corretor sobre cancelamento da negociação:', notifyError);
                }
            }
            return res.status(200).json({
                message: 'Negociação cancelada e imóvel devolvido para disponível.',
                id: negotiationId,
                status: 'CANCELLED',
            });
        }
        catch (error) {
            await tx.rollback();
            console.error('Erro ao cancelar negociação:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
        finally {
            tx.release();
        }
    }
    async downloadSignedProposal(req, res) {
        const negotiationId = String(req.params.id ?? '').trim();
        if (!negotiationId) {
            return res.status(400).json({ error: 'ID de negociação inválido.' });
        }
        try {
            const [rows] = await connection_1.default.query(`
          SELECT id, file_content
          FROM negotiation_documents
          WHERE negotiation_id = ? AND type = 'other'
          ORDER BY created_at DESC, id DESC
          LIMIT 1
        `, [negotiationId]);
            const document = rows[0];
            if (!document?.file_content) {
                return res.status(404).json({ error: 'Proposta assinada não encontrada.' });
            }
            const fileContent = Buffer.isBuffer(document.file_content)
                ? document.file_content
                : Buffer.from(document.file_content);
            res.setHeader('Content-Type', 'application/pdf');
            res.setHeader('Content-Disposition', `inline; filename="proposta_assinada_${negotiationId}.pdf"`);
            res.setHeader('Content-Length', fileContent.length.toString());
            return res.status(200).send(fileContent);
        }
        catch (error) {
            console.error('Erro ao baixar proposta assinada:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async listPropertiesWithBrokers(req, res) {
        try {
            const page = Math.max(parseInt(String(req.query.page ?? '1'), 10) || 1, 1);
            const limit = Math.min(Math.max(parseInt(String(req.query.limit ?? '10'), 10) || 10, 1), 100);
            const offset = (page - 1) * limit;
            const searchTerm = String(req.query.search ?? '').trim();
            const searchColumn = String(req.query.searchColumn ?? 'p.title');
            const status = normalizeStatus(req.query.status);
            const city = String(req.query.city ?? '').trim();
            const sortBy = String(req.query.sortBy ?? 'p.created_at');
            const sortOrder = String(req.query.sortOrder ?? 'desc').toUpperCase() === 'ASC' ? 'ASC' : 'DESC';
            const allowedSearchColumns = new Set([
                'p.id',
                'p.title',
                'p.type',
                'p.city',
                'p.code',
                'u.name',
                'u_owner.name',
            ]);
            const allowedSortColumns = new Set([
                'p.id',
                'p.title',
                'p.type',
                'p.city',
                'u.name',
                'u_owner.name',
                'p.price',
                'p.created_at',
                'p.code',
                'p.status',
            ]);
            const safeSearchColumn = allowedSearchColumns.has(searchColumn) ? searchColumn : 'p.title';
            const safeSortBy = allowedSortColumns.has(sortBy) ? sortBy : 'p.created_at';
            const whereClauses = [];
            const params = [];
            if (searchTerm) {
                whereClauses.push(`${safeSearchColumn} LIKE ?`);
                params.push(`%${searchTerm}%`);
            }
            if (status) {
                whereClauses.push('p.status = ?');
                params.push(status);
            }
            if (city) {
                whereClauses.push('p.city = ?');
                params.push(city);
            }
            const where = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';
            const [totalRows] = await connection_1.default.query(`
          SELECT COUNT(*) AS total
          FROM properties p
          LEFT JOIN brokers b ON p.broker_id = b.id
          LEFT JOIN users u ON b.id = u.id
          LEFT JOIN users u_owner ON u_owner.id = p.owner_id
          ${where}
        `, params);
            const total = totalRows[0]?.total ?? 0;
            const [rows] = await connection_1.default.query(`
          SELECT
            p.id,
            p.code,
            p.title,
            p.type,
            p.status,
            p.price,
            p.price_sale,
            p.price_rent,
            p.promotion_percentage,
            p.promotion_price,
            p.promotional_rent_price,
            p.promotional_rent_percentage,
            p.city,
            p.bairro,
            p.cep,
            p.purpose,
            p.created_at,
            p.broker_id,
            p.owner_id,
            p.owner_name,
            p.owner_phone,
            COALESCE(u.name, u_owner.name) AS broker_name,
            COALESCE(u.phone, u_owner.phone) AS broker_phone,
            b.status AS broker_status,
            b.creci AS broker_creci
          FROM properties p
          LEFT JOIN brokers b ON p.broker_id = b.id
          LEFT JOIN users u ON b.id = u.id
          LEFT JOIN users u_owner ON u_owner.id = p.owner_id
          ${where}
          ORDER BY ${safeSortBy} ${sortOrder}
          LIMIT ? OFFSET ?
        `, [...params, limit, offset]);
            return res.json({ data: rows, total });
        }
        catch (error) {
            console.error('Erro ao listar imoveis com corretores:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async listArchivedProperties(req, res) {
        try {
            const page = Math.max(parseInt(String(req.query.page ?? '1'), 10) || 1, 1);
            const limit = Math.min(Math.max(parseInt(String(req.query.limit ?? '10'), 10) || 10, 1), 100);
            const offset = (page - 1) * limit;
            const search = String(req.query.search ?? '').trim();
            const whereClauses = ["p.status IN ('sold', 'rented')"];
            const params = [];
            if (search) {
                whereClauses.push('(p.code LIKE ? OR p.title LIKE ? OR COALESCE(u.name, u_owner.name) LIKE ?)');
                const searchLike = `%${search}%`;
                params.push(searchLike, searchLike, searchLike);
            }
            const where = `WHERE ${whereClauses.join(' AND ')}`;
            const [countRows] = await connection_1.default.query(`
          SELECT COUNT(*) AS total
          FROM properties p
          LEFT JOIN brokers b ON b.id = p.broker_id
          LEFT JOIN users u ON u.id = b.id
          LEFT JOIN users u_owner ON u_owner.id = p.owner_id
          ${where}
        `, params);
            const total = Number(countRows[0]?.total ?? 0);
            const [rows] = await connection_1.default.query(`
          SELECT
            p.id,
            p.code,
            p.title,
            p.status,
            COALESCE(u.name, u_owner.name) AS broker_name,
            sl.last_sale_date AS transaction_date
          FROM properties p
          LEFT JOIN brokers b ON b.id = p.broker_id
          LEFT JOIN users u ON u.id = b.id
          LEFT JOIN users u_owner ON u_owner.id = p.owner_id
          LEFT JOIN (
            SELECT property_id, MAX(sale_date) AS last_sale_date
            FROM sales
            GROUP BY property_id
          ) sl ON sl.property_id = p.id
          ${where}
          ORDER BY COALESCE(sl.last_sale_date, p.created_at) DESC, p.id DESC
          LIMIT ? OFFSET ?
        `, [...params, limit, offset]);
            return res.status(200).json({
                data: rows.map((row) => ({
                    id: Number(row.id),
                    code: row.code ?? null,
                    title: row.title,
                    status: row.status,
                    brokerName: row.broker_name ?? null,
                    transactionDate: row.transaction_date ? String(row.transaction_date) : null,
                })),
                total,
                page,
                limit,
            });
        }
        catch (error) {
            console.error('Erro ao listar imóveis vendidos/alugados:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async relistProperty(req, res) {
        const propertyId = Number(req.params.id);
        if (Number.isNaN(propertyId)) {
            return res.status(400).json({ error: 'Identificador de imóvel inválido.' });
        }
        const db = await connection_1.default.getConnection();
        try {
            await db.beginTransaction();
            const [rows] = await db.query(`
          SELECT id, status, code, title
          FROM properties
          WHERE id = ?
          LIMIT 1
          FOR UPDATE
        `, [propertyId]);
            if (!rows.length) {
                await db.rollback();
                return res.status(404).json({ error: 'Imóvel não encontrado.' });
            }
            const property = rows[0];
            const currentStatus = String(property.status ?? '').toLowerCase();
            if (currentStatus !== 'rented') {
                await db.rollback();
                return res.status(400).json({
                    error: 'Apenas imóveis alugados podem ser disponibilizados novamente.',
                });
            }
            await db.query(`
          UPDATE properties
          SET
            status = 'approved',
            sale_value = NULL,
            commission_rate = NULL,
            commission_value = NULL
          WHERE id = ?
        `, [propertyId]);
            await db.query(`
          DELETE FROM sales
          WHERE property_id = ?
            AND deal_type = 'rent'
        `, [propertyId]);
            await db.commit();
            return res.status(200).json({
                message: 'Imóvel disponibilizado novamente com sucesso.',
                data: {
                    id: Number(property.id),
                    code: property.code ?? null,
                    title: property.title ?? null,
                    status: 'approved',
                },
            });
        }
        catch (error) {
            await db.rollback();
            console.error('Erro ao disponibilizar imóvel novamente:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
        finally {
            db.release();
        }
    }
    async listFeaturedProperties(req, res) {
        try {
            const [rows] = await connection_1.default.query(`
          SELECT
            fp.property_id AS id,
            fp.position,
            p.title,
            p.city,
            p.state,
            p.status,
            p.price,
            p.price_sale,
            p.price_rent,
            p.promotion_price,
            p.promotional_rent_price,
            p.promotional_rent_percentage,
            p.purpose
          FROM featured_properties fp
          JOIN properties p ON p.id = fp.property_id
          ORDER BY fp.position ASC
        `);
            return res.status(200).json({ data: rows });
        }
        catch (error) {
            console.error('Erro ao listar destaques:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async updateFeaturedProperties(req, res) {
        const rawList = req.body?.propertyIds;
        const input = Array.isArray(rawList) ? rawList : [];
        const seen = new Set();
        const ids = [];
        for (const value of input) {
            const id = Number(value);
            if (!Number.isFinite(id) || id <= 0)
                continue;
            if (seen.has(id))
                continue;
            seen.add(id);
            ids.push(id);
        }
        if (ids.length > 20) {
            return res.status(400).json({ error: 'Limite máximo de 20 destaques.' });
        }
        try {
            if (ids.length > 0) {
                const [approvedRows] = await connection_1.default.query('SELECT id FROM properties WHERE status = ? AND id IN (?)', ['approved', ids]);
                const approvedIds = new Set(approvedRows.map((row) => Number(row.id)).filter((id) => Number.isFinite(id)));
                const invalidIds = ids.filter((id) => !approvedIds.has(id));
                if (invalidIds.length > 0) {
                    return res.status(400).json({
                        error: 'Alguns imoveis não estão aprovados.',
                        invalidIds,
                    });
                }
            }
            const db = await connection_1.default.getConnection();
            try {
                await db.beginTransaction();
                await db.query('DELETE FROM featured_properties');
                if (ids.length > 0) {
                    const values = ids.map((id, index) => [id, index + 1]);
                    await db.query('INSERT INTO featured_properties (property_id, position) VALUES ?', [values]);
                }
                await db.commit();
            }
            catch (error) {
                await db.rollback();
                throw error;
            }
            finally {
                db.release();
            }
            return res.status(200).json({ data: ids });
        }
        catch (error) {
            console.error('Erro ao atualizar destaques:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async updateBroker(req, res) {
        const { id } = req.params;
        const { name, email, phone, creci, status, agencyId, agency_id } = req.body;
        const resolvedAgencyId = agencyId ?? agency_id;
        try {
            await connection_1.default.query('UPDATE users SET name = ?, email = ?, phone = ? WHERE id = ?', [stringOrNull(name), stringOrNull(email), stringOrNull(phone), id]);
            const updates = [];
            const params = [];
            if (creci !== undefined) {
                updates.push('creci = ?');
                params.push(stringOrNull(creci));
            }
            if (status !== undefined) {
                const normalized = normalizeStatus(status);
                if (!normalized) {
                    return res.status(400).json({ error: 'Status de corretor inválido.' });
                }
                updates.push('status = ?');
                params.push(normalized);
            }
            if (resolvedAgencyId !== undefined) {
                updates.push('agency_id = ?');
                params.push(resolvedAgencyId ? Number(resolvedAgencyId) : null);
            }
            if (updates.length > 0) {
                params.push(id);
                await connection_1.default.query(`UPDATE brokers SET ${updates.join(', ')} WHERE id = ?`, params);
            }
            return res.status(200).json({ message: 'Corretor atualizado com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao atualizar corretor:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async updateClient(req, res) {
        const { id } = req.params;
        const { name, email, phone, street, number, complement, bairro, city, state, cep } = req.body;
        const addressResult = (0, address_1.sanitizeAddressInput)({
            street,
            number,
            complement,
            bairro,
            city,
            state,
            cep,
        });
        if (!addressResult.ok) {
            return res.status(400).json({
                error: 'Endereco incompleto ou invalido.',
                fields: addressResult.errors,
            });
        }
        try {
            await connection_1.default.query('UPDATE users SET name = ?, email = ?, phone = ?, street = ?, number = ?, complement = ?, bairro = ?, city = ?, state = ?, cep = ? WHERE id = ?', [
                stringOrNull(name),
                stringOrNull(email),
                stringOrNull(phone),
                addressResult.value.street,
                addressResult.value.number,
                addressResult.value.complement,
                addressResult.value.bairro,
                addressResult.value.city,
                addressResult.value.state,
                addressResult.value.cep,
                id,
            ]);
            return res.status(200).json({ message: 'Cliente atualizado com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao atualizar cliente:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async getAllUsers(req, res) {
        try {
            const page = Math.max(parseInt(String(req.query.page ?? '1'), 10) || 1, 1);
            const limit = Math.min(Math.max(parseInt(String(req.query.limit ?? '10'), 10) || 10, 1), 100);
            const offset = (page - 1) * limit;
            const searchTerm = String(req.query.search ?? '').trim();
            const includeBrokers = String(req.query.includeBrokers ?? '').toLowerCase() === 'true';
            const sortByParam = String(req.query.sortBy ?? '').toLowerCase();
            const sortOrder = String(req.query.sortOrder ?? 'desc').toUpperCase() === 'ASC' ? 'ASC' : 'DESC';
            const sortMap = {
                name: 'u.name',
                email: 'u.email',
                created_at: 'u.created_at',
            };
            const sortBy = sortMap[sortByParam] ?? 'u.created_at';
            const whereClauses = [];
            const params = [];
            if (!includeBrokers) {
                whereClauses.push("(b.id IS NULL OR b.status IN ('rejected'))");
            }
            if (searchTerm) {
                whereClauses.push('(u.name LIKE ? OR u.email LIKE ?)');
                params.push(`%${searchTerm}%`, `%${searchTerm}%`);
            }
            const whereSql = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';
            const [totalRows] = await connection_1.default.query(`SELECT COUNT(*) AS total FROM users u LEFT JOIN brokers b ON u.id = b.id ${whereSql}`, params);
            const total = totalRows[0]?.total ?? 0;
            const [rows] = await connection_1.default.query(`
          SELECT
            u.id,
            u.name,
            u.email,
            u.phone,
            u.created_at,
            CASE
            WHEN b.id IS NOT NULL AND b.status IN ('approved','pending_verification') THEN 'broker'
              ELSE 'client'
            END AS role
          FROM users u
          LEFT JOIN brokers b ON u.id = b.id
          ${whereSql}
          ORDER BY ${sortBy} ${sortOrder}
          LIMIT ? OFFSET ?
        `, [...params, limit, offset]);
            return res.json({ data: rows, total });
        }
        catch (error) {
            console.error('Erro ao listar usuarios:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async deleteUser(req, res) {
        const { id } = req.params;
        try {
            await connection_1.default.query('DELETE FROM users WHERE id = ?', [id]);
            return res.status(200).json({ message: 'Usuario deletado com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao deletar usuario:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async deleteBroker(req, res) {
        const { id } = req.params;
        try {
            await connection_1.default.query('DELETE FROM brokers WHERE id = ?', [id]);
            return res.status(200).json({ message: 'Corretor deletado com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao deletar corretor:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async deleteProperty(req, res) {
        const { id } = req.params;
        try {
            await connection_1.default.query('DELETE FROM properties WHERE id = ?', [id]);
            return res.status(200).json({ message: 'Imovel deletado com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao deletar imovel:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async updateProperty(req, res) {
        const { id } = req.params;
        const body = req.body ?? {};
        try {
            const [propertyRows] = await connection_1.default.query(`
          SELECT
            id,
            status,
            price,
            price_sale,
            price_rent,
            promotion_price,
            promotional_rent_price,
            purpose,
            title,
            is_promoted,
            promotion_percentage,
            promotional_rent_percentage
          FROM properties
          WHERE id = ?
        `, [id]);
            if (propertyRows.length === 0) {
                return res.status(404).json({ error: 'Imovel não encontrado.' });
            }
            const property = propertyRows[0];
            const nextPurpose = normalizePurpose(body.purpose) ?? String(property.purpose ?? '');
            const purposeLower = nextPurpose.toLowerCase();
            const supportsSale = purposeLower.includes('vend');
            const supportsRent = purposeLower.includes('alug');
            const previousSalePrice = toNullableNumber(property.price_sale) ?? toNullableNumber(property.price);
            const previousRentPrice = toNullableNumber(property.price_rent) ??
                (supportsRent && !supportsSale ? toNullableNumber(property.price) : null);
            let nextSalePrice = previousSalePrice;
            let nextRentPrice = previousRentPrice;
            let saleTouched = false;
            let rentTouched = false;
            const previousPromotionFlag = parseBoolean(property.is_promoted);
            let nextPromotionFlag = previousPromotionFlag;
            let nextPromotionPercentage = toNullableNumber(property.promotion_percentage);
            let nextPromotionPrice = toNullableNumber(property.promotion_price);
            let nextPromotionalRentPrice = toNullableNumber(property.promotional_rent_price);
            let nextPromotionalRentPercentage = toNullableNumber(property.promotional_rent_percentage);
            if (Object.prototype.hasOwnProperty.call(body, 'price_sale')) {
                nextSalePrice = parseDecimal(body.price_sale);
                saleTouched = true;
            }
            if (Object.prototype.hasOwnProperty.call(body, 'price_rent')) {
                nextRentPrice = parseDecimal(body.price_rent);
                rentTouched = true;
            }
            if (Object.prototype.hasOwnProperty.call(body, 'price')) {
                const parsed = parseDecimal(body.price);
                if (supportsSale && !supportsRent) {
                    nextSalePrice = parsed;
                    saleTouched = true;
                }
                else if (supportsRent && !supportsSale) {
                    nextRentPrice = parsed;
                    rentTouched = true;
                }
                else if (supportsSale && supportsRent) {
                    nextSalePrice = parsed;
                    saleTouched = true;
                }
            }
            const nextStatus = normalizeStatus(body.status) ?? property.status;
            const shouldNotifyPriceDrop = (nextStatus ?? '').toLowerCase() === 'approved' && (saleTouched || rentTouched);
            const allowedFields = new Set([
                'title',
                'description',
                'type',
                'purpose',
                'status',
                'price',
                'price_sale',
                'price_rent',
                'promotion_price',
                'promotional_price',
                'promotional_rent_price',
                'promotional_rent_percentage',
                'is_promoted',
                'promotion_percentage',
                'promotion_start',
                'promotion_end',
                'code',
                'owner_name',
                'owner_phone',
                'address',
                'quadra',
                'lote',
                'numero',
                'bairro',
                'complemento',
                'tipo_lote',
                'city',
                'state',
                'cep',
                'bedrooms',
                'bathrooms',
                'area_construida',
                'area_terreno',
                'garage_spots',
                'has_wifi',
                'tem_piscina',
                'tem_energia_solar',
                'tem_automacao',
                'tem_ar_condicionado',
                'eh_mobiliada',
                'valor_condominio',
                'valor_iptu',
                'video_url',
                'sale_value',
                'commission_rate',
                'commission_value',
            ]);
            const setParts = [];
            const params = [];
            for (const [key, value] of Object.entries(body)) {
                if (!allowedFields.has(key)) {
                    continue;
                }
                switch (key) {
                    case 'status': {
                        const normalized = normalizeStatus(value);
                        if (!normalized) {
                            return res.status(400).json({ error: 'Status invalido.' });
                        }
                        setParts.push('status = ?');
                        params.push(normalized);
                        break;
                    }
                    case 'purpose': {
                        const normalized = normalizePurpose(value);
                        if (!normalized) {
                            return res.status(400).json({ error: 'Finalidade invalida.' });
                        }
                        setParts.push('purpose = ?');
                        params.push(normalized);
                        break;
                    }
                    case 'type': {
                        const normalized = (0, propertyTypes_1.normalizePropertyType)(value);
                        if (!normalized) {
                            return res.status(400).json({ error: 'Tipo de imóvel inválido.' });
                        }
                        setParts.push('type = ?');
                        params.push(normalized);
                        break;
                    }
                    case 'price':
                    case 'price_sale':
                    case 'price_rent':
                    case 'sale_value':
                    case 'commission_rate':
                    case 'commission_value':
                    case 'area_construida':
                    case 'area_terreno':
                    case 'valor_condominio':
                    case 'valor_iptu': {
                        try {
                            setParts.push(`${key} = ?`);
                            params.push(parseDecimal(value));
                        }
                        catch (parseError) {
                            return res.status(400).json({ error: parseError.message });
                        }
                        break;
                    }
                    case 'bedrooms':
                    case 'bathrooms':
                    case 'garage_spots': {
                        try {
                            setParts.push(`${key} = ?`);
                            params.push(parseInteger(value));
                        }
                        catch (parseError) {
                            return res.status(400).json({ error: parseError.message });
                        }
                        break;
                    }
                    case 'has_wifi':
                    case 'tem_piscina':
                    case 'tem_energia_solar':
                    case 'tem_automacao':
                    case 'tem_ar_condicionado':
                    case 'eh_mobiliada': {
                        setParts.push(`${key} = ?`);
                        params.push(parseBoolean(value));
                        break;
                    }
                    case 'tipo_lote': {
                        setParts.push('tipo_lote = ?');
                        params.push(normalizeTipoLote(value));
                        break;
                    }
                    case 'is_promoted': {
                        const parsed = parseBoolean(value);
                        nextPromotionFlag = parsed;
                        if (parsed === 0) {
                            nextPromotionPercentage = null;
                            nextPromotionPrice = null;
                            nextPromotionalRentPrice = null;
                            setParts.push('promotion_percentage = ?');
                            params.push(null);
                            setParts.push('promotion_start = ?');
                            params.push(null);
                            setParts.push('promotion_end = ?');
                            params.push(null);
                            setParts.push('promotion_price = ?');
                            params.push(null);
                            setParts.push('promotional_rent_price = ?');
                            params.push(null);
                            setParts.push('promotional_rent_percentage = ?');
                            params.push(null);
                        }
                        setParts.push('is_promoted = ?');
                        params.push(parsed);
                        break;
                    }
                    case 'promotion_percentage': {
                        try {
                            const parsed = parsePromotionPercentage(value);
                            nextPromotionPercentage = parsed;
                            setParts.push('promotion_percentage = ?');
                            params.push(parsed);
                            if (parsed != null) {
                                nextPromotionFlag = 1;
                            }
                        }
                        catch (parseError) {
                            return res.status(400).json({ error: parseError.message });
                        }
                        break;
                    }
                    case 'promotional_rent_percentage': {
                        try {
                            const parsed = parsePromotionPercentage(value);
                            nextPromotionalRentPercentage = parsed;
                            setParts.push('promotional_rent_percentage = ?');
                            params.push(parsed);
                            if (parsed != null) {
                                nextPromotionFlag = 1;
                            }
                        }
                        catch (parseError) {
                            return res.status(400).json({ error: parseError.message });
                        }
                        break;
                    }
                    case 'promotion_price':
                    case 'promotional_price':
                    case 'promotional_rent_price': {
                        try {
                            const parsed = parseDecimal(value);
                            if (key === 'promotional_rent_price') {
                                setParts.push('promotional_rent_price = ?');
                                params.push(parsed);
                                nextPromotionalRentPrice = parsed;
                            }
                            else {
                                setParts.push('promotion_price = ?');
                                params.push(parsed);
                                nextPromotionPrice = parsed;
                            }
                            if (parsed != null) {
                                nextPromotionFlag = 1;
                            }
                        }
                        catch (parseError) {
                            return res.status(400).json({ error: parseError.message });
                        }
                        break;
                    }
                    case 'promotion_start':
                    case 'promotion_end': {
                        try {
                            const parsed = parsePromotionDateTime(value);
                            setParts.push(`${key} = ?`);
                            params.push(parsed);
                        }
                        catch (parseError) {
                            return res.status(400).json({ error: parseError.message });
                        }
                        break;
                    }
                    case 'owner_phone': {
                        const text = String(value ?? '').trim();
                        if (text.length === 0) {
                            setParts.push('owner_phone = ?');
                            params.push(null);
                            break;
                        }
                        if (!hasValidPhone(text)) {
                            return res.status(400).json({ error: 'Telefone do proprietário inválido.' });
                        }
                        setParts.push('owner_phone = ?');
                        params.push(normalizePhone(text));
                        break;
                    }
                    default: {
                        if (value === undefined) {
                            continue;
                        }
                        setParts.push(`${key} = ?`);
                        params.push(stringOrNull(value));
                    }
                }
            }
            if (!supportsSale && Object.prototype.hasOwnProperty.call(body, 'promotion_price')) {
                setParts.push('promotion_price = ?');
                params.push(null);
                nextPromotionPrice = null;
            }
            if (!supportsSale && Object.prototype.hasOwnProperty.call(body, 'promotional_price')) {
                setParts.push('promotion_price = ?');
                params.push(null);
                nextPromotionPrice = null;
            }
            if (!supportsRent && Object.prototype.hasOwnProperty.call(body, 'promotional_rent_price')) {
                setParts.push('promotional_rent_price = ?');
                params.push(null);
                nextPromotionalRentPrice = null;
            }
            if (!supportsRent && Object.prototype.hasOwnProperty.call(body, 'promotional_rent_percentage')) {
                setParts.push('promotional_rent_percentage = ?');
                params.push(null);
                nextPromotionalRentPercentage = null;
            }
            if (nextPromotionPrice != null &&
                nextSalePrice != null &&
                Number(nextPromotionPrice) >= Number(nextSalePrice)) {
                return res.status(400).json({
                    error: 'Preço promocional de venda deve ser menor que o preço de venda.',
                });
            }
            if (nextPromotionalRentPrice != null &&
                nextRentPrice != null &&
                Number(nextPromotionalRentPrice) >= Number(nextRentPrice)) {
                return res.status(400).json({
                    error: 'Preço promocional de aluguel deve ser menor que o preço de aluguel.',
                });
            }
            const hasAbsolutePromotion = nextPromotionPrice != null || nextPromotionalRentPrice != null;
            const hasAnyPromotion = hasAbsolutePromotion ||
                nextPromotionPercentage != null ||
                nextPromotionalRentPercentage != null;
            if (hasAnyPromotion && !Object.prototype.hasOwnProperty.call(body, 'is_promoted')) {
                nextPromotionFlag = 1;
                setParts.push('is_promoted = ?');
                params.push(1);
            }
            if (setParts.length === 0) {
                return res.status(400).json({ error: 'Nenhum dado fornecido para atualizacao.' });
            }
            params.push(id);
            await connection_1.default.query(`UPDATE properties SET ${setParts.join(', ')} WHERE id = ?`, params);
            if (shouldNotifyPriceDrop) {
                try {
                    const title = typeof body.title === 'string' && body.title.trim()
                        ? body.title.trim()
                        : String(property.title ?? '');
                    await (0, priceDropNotificationService_1.notifyPriceDropIfNeeded)({
                        propertyId: Number(id),
                        propertyTitle: title,
                        previousSalePrice,
                        newSalePrice: saleTouched ? nextSalePrice : undefined,
                        previousRentPrice,
                        newRentPrice: rentTouched ? nextRentPrice : undefined,
                    });
                }
                catch (notifyError) {
                    console.error('Erro ao notificar queda de preço:', notifyError);
                }
            }
            if (!previousPromotionFlag && nextPromotionFlag === 1) {
                try {
                    const title = typeof body.title === 'string' && body.title.trim()
                        ? body.title.trim()
                        : String(property.title ?? '');
                    await (0, priceDropNotificationService_1.notifyPromotionStarted)({
                        propertyId: Number(id),
                        propertyTitle: title,
                        promotionPercentage: nextPromotionPercentage,
                    });
                }
                catch (notifyError) {
                    console.error('Erro ao notificar início de promoção:', notifyError);
                }
            }
            return res.status(200).json({ message: 'Imóvel atualizado com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao atualizar imovel:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async signCloudinaryUpload(req, res) {
        try {
            const requestedType = typeof req.body?.resource_type === 'string' ? req.body.resource_type.toLowerCase() : 'image';
            if (requestedType !== 'image' && requestedType !== 'video') {
                return res.status(400).json({ error: 'resource_type inválido. Use image ou video.' });
            }
            const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
            const apiKey = process.env.CLOUDINARY_API_KEY;
            const apiSecret = process.env.CLOUDINARY_API_SECRET;
            if (!cloudName || !apiKey || !apiSecret) {
                return res.status(500).json({ error: 'Cloudinary não configurado no servidor.' });
            }
            const timestamp = Math.floor(Date.now() / 1000);
            const folder = requestedType === 'image' ? 'conectimovel/properties/admin' : 'conectimovel/videos';
            const maxFileSize = requestedType === 'image' ? DIRECT_UPLOAD_IMAGE_MAX_BYTES : DIRECT_UPLOAD_VIDEO_MAX_BYTES;
            const allowedFormats = requestedType === 'image' ? CLOUDINARY_IMAGE_ALLOWED_FORMATS : CLOUDINARY_VIDEO_ALLOWED_FORMATS;
            const paramsToSign = {
                folder,
                timestamp,
                max_file_size: maxFileSize,
                allowed_formats: allowedFormats.join(','),
            };
            const signature = cloudinary_1.default.utils.api_sign_request(paramsToSign, apiSecret);
            return res.status(200).json({
                apiKey,
                cloudName,
                signature,
                timestamp,
                folder,
                maxFileSize,
                allowedFormats,
                resourceType: requestedType,
                uploadUrl: `https://api.cloudinary.com/v1_1/${cloudName}/${requestedType}/upload`,
            });
        }
        catch (error) {
            console.error('Erro ao assinar upload do Cloudinary:', error);
            return res.status(500).json({ error: 'Não foi possível preparar upload direto.' });
        }
    }
    async createProperty(req, res) {
        const files = req.files;
        const body = req.body ?? {};
        try {
            const required = [
                'title',
                'description',
                'type',
                'purpose',
                'address',
                'bairro',
                'quadra',
                'lote',
                'tipo_lote',
                'city',
                'state',
                'bedrooms',
                'bathrooms',
                'area_construida',
                'area_terreno',
                'garage_spots',
            ];
            for (const field of required) {
                if (!body[field]) {
                    return res.status(400).json({ error: `Campo obrigatorio ausente: ${field}` });
                }
            }
            const { title, description, type, purpose, status, is_promoted, promotion_percentage, promotion_start, promotion_end, price, price_sale, price_rent, promotion_price, promotional_price, promotional_rent_price, promotional_rent_percentage, code, owner_name, owner_phone, address, quadra, lote, numero, sem_numero, bairro, complemento, tipo_lote, city, state, cep, bedrooms, bathrooms, area_construida, area_terreno, garage_spots, has_wifi, tem_piscina, tem_energia_solar, tem_automacao, tem_ar_condicionado, eh_mobiliada, valor_condominio, valor_iptu, video_url, broker_id, } = body;
            const semNumeroFlag = parseBoolean(sem_numero);
            const normalizedType = (0, propertyTypes_1.normalizePropertyType)(type);
            if (!normalizedType) {
                return res.status(400).json({ error: 'Tipo de imóvel inválido.' });
            }
            const normalizedStatus = normalizeStatus(status) ?? 'approved';
            const normalizedPurpose = normalizePurpose(purpose);
            if (!normalizedPurpose) {
                return res.status(400).json({ error: 'Finalidade invalida.' });
            }
            const numericPrice = parseDecimal(price);
            const numericPriceSale = parseDecimal(price_sale);
            const numericPriceRent = parseDecimal(price_rent);
            let resolvedPrice = null;
            let resolvedPriceSale = null;
            let resolvedPriceRent = null;
            let resolvedPromotionPrice = null;
            let resolvedPromotionalRentPrice = null;
            let promotionPercentage = null;
            let promotionalRentPercentage = null;
            let promotionFlag = 0;
            let promotionStart = null;
            let promotionEnd = null;
            if (normalizedPurpose === 'Venda') {
                resolvedPriceSale = numericPriceSale ?? numericPrice;
                resolvedPrice = resolvedPriceSale;
            }
            else if (normalizedPurpose === 'Aluguel') {
                resolvedPriceRent = numericPriceRent ?? numericPrice;
                resolvedPrice = resolvedPriceRent;
            }
            else {
                resolvedPriceSale = numericPriceSale;
                resolvedPriceRent = numericPriceRent;
                resolvedPrice = resolvedPriceSale;
            }
            if (!resolvedPrice || resolvedPrice <= 0) {
                return res.status(400).json({ error: 'Preco invalido.' });
            }
            if (normalizedPurpose === 'Venda e Aluguel') {
                if (!resolvedPriceSale || resolvedPriceSale <= 0 || !resolvedPriceRent || resolvedPriceRent <= 0) {
                    return res.status(400).json({ error: 'Informe os precos de venda e aluguel.' });
                }
            }
            resolvedPromotionPrice = parseDecimal(promotion_price ?? promotional_price);
            resolvedPromotionalRentPrice = parseDecimal(promotional_rent_price);
            try {
                promotionPercentage = parsePromotionPercentage(promotion_percentage);
                promotionalRentPercentage = parsePromotionPercentage(promotional_rent_percentage);
            }
            catch (parseError) {
                return res.status(400).json({ error: parseError.message });
            }
            if (normalizedPurpose === 'Venda') {
                resolvedPromotionalRentPrice = null;
                promotionalRentPercentage = null;
            }
            else if (normalizedPurpose === 'Aluguel') {
                resolvedPromotionPrice = null;
                promotionPercentage = null;
            }
            if (resolvedPromotionPrice == null &&
                promotionPercentage != null &&
                resolvedPriceSale != null) {
                resolvedPromotionPrice = Number((resolvedPriceSale * (1 - promotionPercentage / 100)).toFixed(2));
            }
            if (resolvedPromotionalRentPrice == null &&
                promotionalRentPercentage != null &&
                resolvedPriceRent != null) {
                resolvedPromotionalRentPrice = Number((resolvedPriceRent * (1 - promotionalRentPercentage / 100)).toFixed(2));
            }
            if (resolvedPromotionPrice != null &&
                resolvedPriceSale != null &&
                resolvedPromotionPrice >= resolvedPriceSale) {
                return res.status(400).json({
                    error: 'Preço promocional de venda deve ser menor que o preço de venda.',
                });
            }
            if (resolvedPromotionalRentPrice != null &&
                resolvedPriceRent != null &&
                resolvedPromotionalRentPrice >= resolvedPriceRent) {
                return res.status(400).json({
                    error: 'Preço promocional de aluguel deve ser menor que o preço de aluguel.',
                });
            }
            const numericBedrooms = parseInteger(bedrooms);
            const numericBathrooms = parseInteger(bathrooms);
            const numericGarageSpots = parseInteger(garage_spots);
            const numericAreaConstruida = parseDecimal(area_construida);
            const numericAreaTerreno = parseDecimal(area_terreno);
            const numericValorCondominio = parseDecimal(valor_condominio);
            const numericValorIptu = parseDecimal(valor_iptu);
            const brokerIdValue = broker_id ? Number(broker_id) : null;
            const hasWifiFlag = parseBoolean(has_wifi);
            const temPiscinaFlag = parseBoolean(tem_piscina);
            const temEnergiaSolarFlag = parseBoolean(tem_energia_solar);
            const temAutomacaoFlag = parseBoolean(tem_automacao);
            const temArCondicionadoFlag = parseBoolean(tem_ar_condicionado);
            const ehMobiliadaFlag = parseBoolean(eh_mobiliada);
            try {
                promotionFlag = parseBoolean(is_promoted);
                promotionStart = parsePromotionDateTime(promotion_start);
                promotionEnd = parsePromotionDateTime(promotion_end);
                if (resolvedPromotionPrice != null ||
                    resolvedPromotionalRentPrice != null ||
                    promotionPercentage != null ||
                    promotionalRentPercentage != null) {
                    promotionFlag = 1;
                }
                if (promotionFlag === 0) {
                    promotionPercentage = null;
                    promotionalRentPercentage = null;
                    promotionStart = null;
                    promotionEnd = null;
                }
            }
            catch (parseError) {
                return res.status(400).json({ error: parseError.message });
            }
            const normalizedTipoLote = normalizeTipoLote(tipo_lote);
            if (!normalizedTipoLote) {
                return res.status(400).json({ error: 'Tipo de lote inválido.' });
            }
            if (owner_phone && String(owner_phone).trim().length > 0 && !hasValidPhone(owner_phone)) {
                return res.status(400).json({ error: 'Telefone do proprietário inválido.' });
            }
            if (semNumeroFlag !== 1 && numero && String(numero).trim().length > 0 && !normalizeDigits(numero)) {
                return res.status(400).json({ error: 'Número do endereço deve conter apenas dígitos.' });
            }
            const normalizedNumero = semNumeroFlag === 1 ? null : stringOrNull(normalizeDigits(numero));
            if (numericBedrooms == null ||
                numericBathrooms == null ||
                numericGarageSpots == null ||
                numericAreaConstruida == null ||
                numericAreaTerreno == null) {
                return res.status(400).json({ error: 'Campos numéricos obrigatórios inválidos.' });
            }
            const [duplicateRows] = await connection_1.default.query(`
          SELECT id FROM properties
          WHERE address = ?
            AND COALESCE(quadra, '') = COALESCE(?, '')
            AND COALESCE(lote, '') = COALESCE(?, '')
            AND COALESCE(numero, '') = COALESCE(?, '')
            AND COALESCE(bairro, '') = COALESCE(?, '')
          LIMIT 1
        `, [address, quadra ?? null, lote ?? null, normalizedNumero, bairro ?? null]);
            if (duplicateRows.length > 0) {
                return res.status(409).json({ error: 'Imovel ja cadastrado no sistema.' });
            }
            const uploadImages = files?.images ?? [];
            const bodyRecord = body;
            const providedImageUrls = parseImageUrlsInput(bodyRecord).filter((url) => isAllowedCloudinaryMediaUrl(url, 'conectimovel/properties/admin'));
            const uploadedImageUrls = uploadImages.length > 0
                ? await uploadImagesWithConcurrency(uploadImages, 'properties/admin')
                : [];
            const imageUrls = Array.from(new Set([...providedImageUrls, ...uploadedImageUrls]));
            if (imageUrls.length < 1) {
                return res.status(400).json({ error: 'Envie pelo menos 1 imagem do imóvel.' });
            }
            if (imageUrls.length > MAX_IMAGES_PER_PROPERTY) {
                return res.status(400).json({ error: `Limite máximo de ${MAX_IMAGES_PER_PROPERTY} imagens por imóvel.` });
            }
            let finalVideoUrl = null;
            const uploadVideos = files?.video ?? [];
            if (uploadVideos[0]) {
                const uploadedVideo = await (0, cloudinary_1.uploadToCloudinary)(uploadVideos[0], 'videos');
                finalVideoUrl = uploadedVideo.url;
            }
            else if (video_url && isAllowedCloudinaryMediaUrl(String(video_url), 'conectimovel/videos')) {
                finalVideoUrl = String(video_url);
            }
            const [result] = await connection_1.default.query(`
          INSERT INTO properties (
            broker_id,
            title,
            description,
            type,
            purpose,
            status,
            is_promoted,
            promotion_percentage,
            promotion_start,
            promotion_end,
            price,
            price_sale,
            price_rent,
            promotion_price,
            promotional_rent_price,
            promotional_rent_percentage,
            code,
            owner_name,
            owner_phone,
            address,
            quadra,
            lote,
            numero,
            bairro,
            complemento,
            tipo_lote,
            city,
            state,
            cep,
            bedrooms,
            bathrooms,
            area_construida,
            area_terreno,
            garage_spots,
            has_wifi,
            tem_piscina,
            tem_energia_solar,
            tem_automacao,
            tem_ar_condicionado,
            eh_mobiliada,
            valor_condominio,
            valor_iptu,
            video_url
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
                brokerIdValue,
                title,
                description,
                normalizedType,
                normalizedPurpose,
                normalizedStatus,
                promotionFlag,
                promotionPercentage,
                promotionStart,
                promotionEnd,
                resolvedPrice,
                resolvedPriceSale,
                resolvedPriceRent,
                resolvedPromotionPrice,
                resolvedPromotionalRentPrice,
                promotionalRentPercentage,
                stringOrNull(code),
                stringOrNull(owner_name),
                owner_phone ? normalizePhone(owner_phone) : null,
                address,
                stringOrNull(quadra),
                stringOrNull(lote),
                normalizedNumero,
                stringOrNull(bairro),
                stringOrNull(complemento),
                normalizedTipoLote,
                city,
                state,
                stringOrNull(cep),
                numericBedrooms,
                numericBathrooms,
                numericAreaConstruida,
                numericAreaTerreno,
                numericGarageSpots,
                hasWifiFlag,
                temPiscinaFlag,
                temEnergiaSolarFlag,
                temAutomacaoFlag,
                temArCondicionadoFlag,
                ehMobiliadaFlag,
                numericValorCondominio,
                numericValorIptu,
                finalVideoUrl,
            ]);
            const propertyId = result.insertId;
            if (imageUrls.length > 0) {
                const values = imageUrls.map((url) => [propertyId, url]);
                await connection_1.default.query('INSERT INTO property_images (property_id, image_url) VALUES ?', [values]);
            }
            if (promotionFlag === 1) {
                try {
                    await (0, priceDropNotificationService_1.notifyPromotionStarted)({
                        propertyId,
                        propertyTitle: title,
                        promotionPercentage,
                    });
                }
                catch (promotionNotifyError) {
                    console.error('Erro ao notificar favoritos sobre promocao (create admin):', promotionNotifyError);
                }
            }
            try {
                await (0, notificationService_1.notifyAdmins)(`Um novo imovel '${title}' foi criado pelo admin.`, 'property', propertyId);
            }
            catch (notifyError) {
                console.error('Erro ao notificar admins sobre novo imovel:', notifyError);
            }
            return res.status(201).json({
                message: 'Imovel criado com sucesso!',
                propertyId,
                images: imageUrls,
                video: finalVideoUrl,
                status: normalizedStatus,
            });
        }
        catch (error) {
            console.error('Erro ao criar imovel pelo admin:', error);
            const knownError = error;
            if (knownError?.statusCode === 413) {
                return res.status(413).json({
                    error: knownError.message ||
                        'Arquivo muito grande para upload. Reduza o tamanho do arquivo e tente novamente.',
                });
            }
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async createBroker(req, res) {
        const { name, email, phone, creci, street, number, complement, bairro, city, state, cep, agency_id, password, status, } = req.body ?? {};
        const files = req.files;
        if (!name || !email || !creci || !password || !phone) {
            return res.status(400).json({ error: 'Nome, email, telefone, senha e CRECI são obrigatórios.' });
        }
        if (!isValidEmail(email)) {
            return res.status(400).json({ error: 'Email inválido.' });
        }
        if (!hasValidPhone(phone)) {
            return res.status(400).json({ error: 'Telefone inválido. Use 11 dígitos com DDD.' });
        }
        if (!(0, creci_1.hasValidCreci)(creci)) {
            return res.status(400).json({
                error: 'CRECI inválido. Use 4 a 8 números com sufixo opcional (ex: 12345678-A).',
            });
        }
        if (!normalizeDigits(number)) {
            return res.status(400).json({ error: 'Número do endereço deve conter apenas dígitos.' });
        }
        if (!files?.creciFront?.[0] || !files?.creciBack?.[0] || !files?.selfie?.[0]) {
            return res.status(400).json({
                error: 'Para cadastrar corretor com documentos, envie frente do CRECI, verso do CRECI e selfie.',
            });
        }
        const hasAnyBrokerDocument = true;
        const addressResult = (0, address_1.sanitizeAddressInput)({
            street,
            number,
            complement,
            bairro,
            city,
            state,
            cep,
        });
        if (!addressResult.ok) {
            return res.status(400).json({
                error: 'Endereco incompleto ou invalido.',
                fields: addressResult.errors,
            });
        }
        const db = await connection_1.default.getConnection();
        try {
            await db.beginTransaction();
            const [existing] = await db.query('SELECT id FROM users WHERE email = ? LIMIT 1', [email]);
            if (existing.length > 0) {
                await db.rollback();
                return res.status(409).json({ error: 'Email ja cadastrado.' });
            }
            let passwordHash = null;
            if (password) {
                const salt = await bcryptjs_1.default.genSalt(10);
                passwordHash = await bcryptjs_1.default.hash(String(password), salt);
            }
            const requestedStatus = normalizeStatus(status);
            const brokerStatus = requestedStatus === 'approved' ? 'approved' : 'pending_verification';
            const documentStatus = brokerStatus === 'approved' ? 'approved' : 'pending';
            const [userResult] = await db.query('INSERT INTO users (name, email, phone, password_hash, street, number, complement, bairro, city, state, cep) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)', [
                name,
                email,
                normalizePhone(phone),
                passwordHash,
                addressResult.value.street,
                normalizeDigits(addressResult.value.number),
                addressResult.value.complement,
                addressResult.value.bairro,
                addressResult.value.city,
                addressResult.value.state,
                addressResult.value.cep,
            ]);
            const userId = userResult.insertId;
            await db.query('INSERT INTO brokers (id, creci, status, agency_id) VALUES (?, ?, ?, ?)', [userId, (0, creci_1.normalizeCreci)(creci), brokerStatus, agency_id ? Number(agency_id) : null]);
            if (hasAnyBrokerDocument) {
                const creciFrontResult = await (0, cloudinary_1.uploadToCloudinary)(files.creciFront[0], 'brokers/documents');
                const creciBackResult = await (0, cloudinary_1.uploadToCloudinary)(files.creciBack[0], 'brokers/documents');
                const selfieResult = await (0, cloudinary_1.uploadToCloudinary)(files.selfie[0], 'brokers/documents');
                await db.query(`INSERT INTO broker_documents (broker_id, creci_front_url, creci_back_url, selfie_url, status)
           VALUES (?, ?, ?, ?, ?)
           ON DUPLICATE KEY UPDATE
             creci_front_url = VALUES(creci_front_url),
             creci_back_url = VALUES(creci_back_url),
             selfie_url = VALUES(selfie_url),
             status = VALUES(status),
             updated_at = CURRENT_TIMESTAMP`, [userId, creciFrontResult.url, creciBackResult.url, selfieResult.url, documentStatus]);
            }
            await db.commit();
            try {
                await (0, notificationService_1.notifyAdmins)(`Novo corretor '${name}' cadastrado com status '${brokerStatus}'.`, 'broker', userId);
            }
            catch (notifyError) {
                console.error('Erro ao notificar admins sobre novo corretor:', notifyError);
            }
            return res.status(201).json({ message: 'Corretor criado com sucesso.', broker_id: userId });
        }
        catch (error) {
            await db.rollback();
            console.error('Erro ao criar corretor:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
        finally {
            db.release();
        }
    }
    async createUser(req, res) {
        const { name, email, phone, password, street, number, complement, bairro, city, state, cep } = req.body ?? {};
        if (!name || !email || !phone || !password) {
            return res.status(400).json({ error: 'Nome, email, telefone e senha são obrigatórios.' });
        }
        if (!isValidEmail(email)) {
            return res.status(400).json({ error: 'Email inválido.' });
        }
        if (!hasValidPhone(phone)) {
            return res.status(400).json({ error: 'Telefone inválido. Use 11 dígitos com DDD.' });
        }
        if (!normalizeDigits(number)) {
            return res.status(400).json({ error: 'Número do endereço deve conter apenas dígitos.' });
        }
        const addressResult = (0, address_1.sanitizeAddressInput)({
            street,
            number,
            complement,
            bairro,
            city,
            state,
            cep,
        });
        if (!addressResult.ok) {
            return res.status(400).json({
                error: 'Endereco incompleto ou invalido.',
                fields: addressResult.errors,
            });
        }
        try {
            const [existing] = await connection_1.default.query('SELECT id FROM users WHERE email = ? LIMIT 1', [email]);
            if (existing.length > 0) {
                return res.status(409).json({ error: 'Email ja cadastrado.' });
            }
            let passwordHash = null;
            if (password) {
                const salt = await bcryptjs_1.default.genSalt(10);
                passwordHash = await bcryptjs_1.default.hash(String(password), salt);
            }
            const [userResult] = await connection_1.default.query('INSERT INTO users (name, email, phone, password_hash, street, number, complement, bairro, city, state, cep) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)', [
                name,
                email,
                normalizePhone(phone),
                passwordHash,
                addressResult.value.street,
                normalizeDigits(addressResult.value.number),
                addressResult.value.complement,
                addressResult.value.bairro,
                addressResult.value.city,
                addressResult.value.state,
                addressResult.value.cep,
            ]);
            return res.status(201).json({ message: 'Usuario criado com sucesso.', user_id: userResult.insertId });
        }
        catch (error) {
            console.error('Erro ao criar usuario:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async listPendingBrokers(req, res) {
        try {
            const [rows] = await connection_1.default.query(`
          SELECT
            b.id,
            u.name,
            u.email,
            u.phone,
            b.creci,
            b.status,
            bd.creci_front_url,
            bd.creci_back_url,
            bd.selfie_url,
            bd.status AS document_status,
            b.created_at
          FROM brokers b
          INNER JOIN users u ON b.id = u.id
          LEFT JOIN broker_documents bd ON b.id = bd.broker_id
          WHERE b.status = 'pending_verification'
            AND (bd.status = 'pending' OR bd.status IS NULL)
        `);
            return res.status(200).json({ data: rows });
        }
        catch (error) {
            console.error('Erro ao buscar corretores pendentes:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async getAllClients(req, res) {
        try {
            const [rows] = await connection_1.default.query(`
          SELECT u.id, u.name, u.email, u.phone, u.created_at
          FROM users u
          LEFT JOIN brokers b ON u.id = b.id
          WHERE b.id IS NULL
        `);
            return res.status(200).json({ data: rows, total: rows.length });
        }
        catch (error) {
            console.error('Erro ao buscar clientes:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async getClientById(req, res) {
        const clientId = Number(req.params.id);
        if (Number.isNaN(clientId)) {
            return res.status(400).json({ error: 'Identificador de cliente invalido.' });
        }
        try {
            const [rows] = await connection_1.default.query(`
          SELECT
            u.id,
            u.name,
            u.email,
            u.phone,
            u.street,
            u.number,
            u.complement,
            u.bairro,
            u.city,
            u.state,
            u.cep,
            u.created_at
          FROM users u
          LEFT JOIN brokers b ON u.id = b.id
          WHERE u.id = ? AND b.id IS NULL
          LIMIT 1
        `, [clientId]);
            if (!rows || rows.length === 0) {
                return res.status(404).json({ error: 'Cliente nao encontrado.' });
            }
            return res.status(200).json({ data: rows[0] });
        }
        catch (error) {
            console.error('Erro ao buscar cliente:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async approveBroker(req, res) {
        const { id } = req.params;
        try {
            await connection_1.default.query('UPDATE brokers SET status = ?, creci = IFNULL(creci, NULL) WHERE id = ?', ['approved', id]);
            await connection_1.default.query('UPDATE broker_documents SET status = ? WHERE broker_id = ?', ['approved', id]);
            try {
                await (0, notificationService_1.notifyAdmins)(`Corretor #${id} aprovado pelo admin.`, 'broker', Number(id));
            }
            catch (notifyError) {
                console.error('Erro ao notificar admins sobre aprovacao de corretor:', notifyError);
            }
            try {
                const brokerId = Number(id);
                if (Number.isFinite(brokerId)) {
                    const role = await (0, userNotificationService_1.resolveUserNotificationRole)(brokerId);
                    if (role === 'broker') {
                        await (0, userNotificationService_1.notifyUsers)({
                            message: 'Sua conta de corretor foi aprovada. Voce ja pode anunciar imoveis.',
                            recipientIds: [brokerId],
                            recipientRole: 'broker',
                            relatedEntityType: 'broker',
                            relatedEntityId: brokerId,
                        });
                    }
                }
            }
            catch (notifyError) {
                console.error('Erro ao notificar corretor aprovado:', notifyError);
            }
            return res.status(200).json({ message: 'Corretor aprovado com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao aprovar corretor:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async rejectBroker(req, res) {
        const { id } = req.params;
        try {
            await connection_1.default.query('DELETE FROM broker_documents WHERE broker_id = ?', [id]);
            await connection_1.default.query('DELETE FROM brokers WHERE id = ?', [id]);
            try {
                await (0, notificationService_1.notifyAdmins)(`Corretor #${id} rejeitado pelo admin.`, 'broker', Number(id));
            }
            catch (notifyError) {
                console.error('Erro ao notificar admins sobre rejeicao de corretor:', notifyError);
            }
            return res.status(200).json({ message: 'Corretor rejeitado com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao rejeitar corretor:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async cleanupBroker(req, res) {
        const brokerId = Number(req.params.id);
        if (Number.isNaN(brokerId)) {
            return res.status(400).json({ error: 'Identificador de corretor invalido.' });
        }
        try {
            await connection_1.default.query('DELETE FROM broker_documents WHERE broker_id = ?', [brokerId]);
            await connection_1.default.query('DELETE FROM brokers WHERE id = ?', [brokerId]);
            await connection_1.default.query('UPDATE properties SET broker_id = NULL WHERE broker_id = ?', [brokerId]);
            try {
                await (0, userNotificationService_1.notifyUsers)({
                    message: 'Sua solicitacao para se tornar corretor foi rejeitada.',
                    recipientIds: [brokerId],
                    recipientRole: 'client',
                    relatedEntityType: 'broker',
                    relatedEntityId: brokerId,
                });
            }
            catch (notifyError) {
                console.error('Erro ao notificar rejeição de corretor:', notifyError);
            }
            return res.status(200).json({ message: 'Corretor removido do sistema com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao limpar corretor:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async updateBrokerStatus(req, res) {
        const brokerId = Number(req.params.id);
        const { status } = req.body ?? {};
        if (Number.isNaN(brokerId)) {
            return res.status(400).json({ error: 'Identificador de corretor inválido.' });
        }
        if (typeof status !== 'string') {
            return res.status(400).json({ error: 'Status inválido.' });
        }
        const normalizedStatus = status.trim();
        const allowedStatuses = new Set(['pending_verification', 'approved', 'rejected']);
        if (!allowedStatuses.has(normalizedStatus)) {
            return res.status(400).json({ error: 'Status de corretor não suportado.' });
        }
        try {
            const [result] = await connection_1.default.query('UPDATE brokers SET status = ? WHERE id = ?', [normalizedStatus, brokerId]);
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Corretor não encontrado.' });
            }
            if (normalizedStatus === 'approved') {
                await connection_1.default.query('UPDATE broker_documents SET status = ? WHERE broker_id = ?', [
                    normalizedStatus,
                    brokerId,
                ]);
            }
            if (normalizedStatus === 'rejected') {
                await connection_1.default.query('DELETE FROM broker_documents WHERE broker_id = ?', [brokerId]);
                await connection_1.default.query('DELETE FROM brokers WHERE id = ?', [brokerId]);
                return res.status(200).json({
                    message: 'Status do corretor atualizado com sucesso.',
                    status: normalizedStatus,
                });
            }
            try {
                await (0, notificationService_1.notifyAdmins)(`Status do corretor #${brokerId} atualizado para ${normalizedStatus}.`, 'broker', brokerId);
            }
            catch (notifyError) {
                console.error('Erro ao notificar admins sobre status do corretor:', notifyError);
            }
            if (normalizedStatus === 'approved') {
                try {
                    const role = await (0, userNotificationService_1.resolveUserNotificationRole)(brokerId);
                    if (role === 'broker') {
                        await (0, userNotificationService_1.notifyUsers)({
                            message: 'Sua conta de corretor foi aprovada. Voce ja pode anunciar imoveis.',
                            recipientIds: [brokerId],
                            recipientRole: 'broker',
                            relatedEntityType: 'broker',
                            relatedEntityId: brokerId,
                        });
                    }
                }
                catch (notifyError) {
                    console.error('Erro ao notificar corretor aprovado:', notifyError);
                }
            }
            return res.status(200).json({
                message: 'Status do corretor atualizado com sucesso.',
                status: normalizedStatus,
            });
        }
        catch (error) {
            console.error('Erro ao atualizar status do corretor:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async listBrokers(req, res) {
        try {
            const page = Math.max(parseInt(String(req.query.page ?? '1'), 10) || 1, 1);
            const limit = Math.min(Math.max(parseInt(String(req.query.limit ?? '10'), 10) || 10, 1), 100);
            const offset = (page - 1) * limit;
            const requestedStatusRaw = String(req.query.status ?? '').trim();
            const requestedStatus = requestedStatusRaw.length == 0 ? 'approved' : requestedStatusRaw;
            const searchTerm = String(req.query.search ?? '').trim();
            const allowedStatuses = new Set(['pending_verification', 'approved', 'rejected', 'all']);
            const whereClauses = [];
            const params = [];
            if (requestedStatus && allowedStatuses.has(requestedStatus)) {
                if (requestedStatus != 'all') {
                    whereClauses.push('b.status = ?');
                    params.push(requestedStatus);
                }
            }
            else if (requestedStatusRaw.length > 0) {
                return res.status(400).json({ error: 'Status de corretor inválido.' });
            }
            if (searchTerm) {
                whereClauses.push('(u.name LIKE ? OR u.email LIKE ? OR b.creci LIKE ?)');
                params.push(`%${searchTerm}%`, `%${searchTerm}%`, `%${searchTerm}%`);
            }
            const where = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';
            const sortMap = {
                name: 'u.name',
                property_count: 'property_count',
                created_at: 'b.created_at',
                status: 'b.status',
                creci: 'b.creci',
            };
            const sortByParam = String(req.query.sortBy ?? '').toLowerCase();
            const sortBy = sortMap[sortByParam] ?? 'b.created_at';
            const sortOrder = String(req.query.sortOrder ?? 'desc').toUpperCase() === 'ASC' ? 'ASC' : 'DESC';
            const [totalRows] = await connection_1.default.query(`
          SELECT COUNT(DISTINCT b.id) AS total
          FROM brokers b
          INNER JOIN users u ON b.id = u.id
          ${where}
        `, params);
            const total = totalRows[0]?.total ?? 0;
            const [rows] = await connection_1.default.query(`
          SELECT
            b.id,
            u.name,
            u.email,
            u.phone,
            b.creci,
            b.status,
            b.created_at,
            a.id AS agency_id,
            a.name AS agency_name,
            a.logo_url AS agency_logo_url,
            a.address AS agency_address,
            a.city AS agency_city,
            a.state AS agency_state,
            a.phone AS agency_phone,
            a.email AS agency_email,
            bd.creci_front_url,
            bd.creci_back_url,
            bd.selfie_url,
            COUNT(p.id) AS property_count
          FROM brokers b
          INNER JOIN users u ON b.id = u.id
          LEFT JOIN agencies a ON b.agency_id = a.id
          LEFT JOIN broker_documents bd ON bd.broker_id = b.id
          LEFT JOIN properties p ON p.broker_id = b.id
          ${where}
          GROUP BY
            b.id,
            u.name,
            u.email,
            u.phone,
            b.creci,
            b.status,
            b.created_at,
            a.id,
            a.name,
            a.logo_url,
            a.address,
            a.city,
            a.state,
            a.phone,
            a.email,
            bd.creci_front_url,
            bd.creci_back_url,
            bd.selfie_url
          ORDER BY ${sortBy} ${sortOrder}
          LIMIT ? OFFSET ?
        `, [...params, limit, offset]);
            const mappedRows = rows.map((row) => ({
                ...row,
                documents: {
                    creci_front_url: row.creci_front_url ?? null,
                    creci_back_url: row.creci_back_url ?? null,
                    selfie_url: row.selfie_url ?? null,
                },
            }));
            return res.json({ data: mappedRows, total });
        }
        catch (error) {
            console.error('Erro ao buscar corretores:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async getBrokerById(req, res) {
        const brokerId = Number(req.params.id);
        if (Number.isNaN(brokerId)) {
            return res.status(400).json({ error: 'Identificador de corretor invalido.' });
        }
        try {
            const [rows] = await connection_1.default.query(`
          SELECT
            b.id,
            u.name,
            u.email,
            u.phone,
            u.street,
            u.number,
            u.complement,
            u.bairro,
            u.city,
            u.state,
            u.cep,
            u.created_at,
            b.creci,
            b.status,
            b.agency_id
          FROM brokers b
          INNER JOIN users u ON b.id = u.id
          WHERE b.id = ?
          LIMIT 1
        `, [brokerId]);
            if (!rows || rows.length === 0) {
                return res.status(404).json({ error: 'Corretor nao encontrado.' });
            }
            return res.status(200).json({ data: rows[0] });
        }
        catch (error) {
            console.error('Erro ao buscar corretor:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async getPropertyDetails(req, res) {
        const propertyId = Number(req.params.id);
        if (Number.isNaN(propertyId)) {
            return res.status(400).json({ error: 'Identificador de imovel inválido.' });
        }
        try {
            const [rows] = await connection_1.default.query(`
          SELECT
            p.*,
            ANY_VALUE(COALESCE(u.name, u_owner.name)) AS broker_name,
            ANY_VALUE(COALESCE(u.phone, u_owner.phone)) AS broker_phone,
            ANY_VALUE(b.status) AS broker_status,
            ANY_VALUE(b.creci) AS broker_creci
          FROM properties p
          LEFT JOIN brokers b ON p.broker_id = b.id
          LEFT JOIN users u ON u.id = b.id
          LEFT JOIN users u_owner ON u_owner.id = p.owner_id
          WHERE p.id = ?
          GROUP BY p.id
        `, [propertyId]);
            if (!rows || rows.length === 0) {
                return res.status(404).json({ error: 'Imóvel não encontrado.' });
            }
            const property = rows[0];
            const [imageRows] = await connection_1.default.query(`
          SELECT id, image_url
          FROM property_images
          WHERE property_id = ?
          ORDER BY id ASC
        `, [propertyId]);
            property.images = imageRows
                .map((row) => {
                const imageId = Number(row.id);
                const imageUrl = typeof row.image_url === 'string' ? row.image_url.trim() : '';
                if (!Number.isFinite(imageId) || imageUrl.length === 0) {
                    return null;
                }
                return `${imageId}|${imageUrl}`;
            })
                .filter((item) => Boolean(item));
            return res.status(200).json(mapAdminProperty(property));
        }
        catch (error) {
            console.error('Erro ao buscar detalhes do imóvel:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async approveProperty(req, res) {
        const propertyId = Number(req.params.id);
        if (Number.isNaN(propertyId)) {
            return res.status(400).json({ error: 'Identificador de imovel inválido.' });
        }
        try {
            const [result] = await connection_1.default.query('UPDATE properties SET status = ? WHERE id = ?', [
                'approved',
                propertyId,
            ]);
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Imovel não encontrado.' });
            }
            try {
                await (0, notificationService_1.notifyAdmins)(`Imovel #${propertyId} aprovado pelo admin.`, 'property', propertyId);
            }
            catch (notifyError) {
                console.error('Erro ao notificar admins sobre aprovação de imovel:', notifyError);
            }
            try {
                const { ownerId, title } = await fetchPropertyOwner(propertyId);
                if (ownerId) {
                    const propertyLabel = title && title.trim().length > 0 ? title.trim() : 'sem titulo';
                    const role = await (0, userNotificationService_1.resolveUserNotificationRole)(ownerId);
                    await (0, userNotificationService_1.notifyUsers)({
                        message: `Seu imovel "${propertyLabel}" foi aprovado e ja esta disponivel no app.`,
                        recipientIds: [ownerId],
                        recipientRole: role,
                        relatedEntityType: 'property',
                        relatedEntityId: propertyId,
                    });
                }
            }
            catch (notifyError) {
                console.error('Erro ao notificar usuario sobre aprovacao do imovel:', notifyError);
            }
            return res.status(200).json({ message: 'Imóvel aprovado com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao aprovar imóvel:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async rejectProperty(req, res) {
        const propertyId = Number(req.params.id);
        if (Number.isNaN(propertyId)) {
            return res.status(400).json({ error: 'Identificador de imovel invalido.' });
        }
        try {
            const { ownerId, title } = await fetchPropertyOwner(propertyId);
            if (!ownerId && !title) {
                return res.status(404).json({ error: 'Imovel nao encontrado.' });
            }
            const [result] = await connection_1.default.query('DELETE FROM properties WHERE id = ?', [propertyId]);
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Imovel nao encontrado.' });
            }
            const propertyLabel = title && title.trim().length > 0 ? title.trim() : 'sem titulo';
            try {
                await (0, notificationService_1.notifyAdmins)(`Imovel #${propertyId} rejeitado e removido pelo admin.`, 'property', propertyId);
            }
            catch (notifyError) {
                console.error('Erro ao notificar admins sobre rejeicao de imovel:', notifyError);
            }
            try {
                if (ownerId) {
                    const role = await (0, userNotificationService_1.resolveUserNotificationRole)(ownerId);
                    await (0, userNotificationService_1.notifyUsers)({
                        message: `Seu imovel "${propertyLabel}" foi rejeitado e removido. Voce pode cadastrar novamente com as informacoes corrigidas.`,
                        recipientIds: [ownerId],
                        recipientRole: role,
                        relatedEntityType: 'property',
                        relatedEntityId: propertyId,
                    });
                }
            }
            catch (notifyError) {
                console.error('Erro ao notificar usuario sobre rejeicao do imovel:', notifyError);
            }
            return res.status(200).json({ message: 'Imóvel rejeitado e removido com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao rejeitar imovel:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async updatePropertyStatus(req, res) {
        const propertyId = Number(req.params.id);
        const { status } = req.body ?? {};
        if (Number.isNaN(propertyId)) {
            return res.status(400).json({ error: 'Identificador de imóvel invalido.' });
        }
        if (typeof status !== 'string') {
            return res.status(400).json({ error: 'Status inválido.' });
        }
        const normalizedStatus = status.trim();
        const allowedStatuses = new Set(['pending_approval', 'approved', 'rejected', 'rented', 'sold']);
        if (!allowedStatuses.has(normalizedStatus)) {
            return res.status(400).json({ error: 'Status de imóvel nao suportado.' });
        }
        if (normalizedStatus === 'rejected') {
            return this.rejectProperty(req, res);
        }
        try {
            const [result] = await connection_1.default.query('UPDATE properties SET status = ? WHERE id = ?', [normalizedStatus, propertyId]);
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Imovel nao encontrado.' });
            }
            try {
                await (0, notificationService_1.notifyAdmins)(`Status do imovel #${propertyId} atualizado para ${normalizedStatus}.`, 'property', propertyId);
            }
            catch (notifyError) {
                console.error('Erro ao notificar admins sobre status de imovel:', notifyError);
            }
            if (normalizedStatus === 'approved' || normalizedStatus === 'rejected') {
                try {
                    const { ownerId, title } = await fetchPropertyOwner(propertyId);
                    if (ownerId) {
                        const propertyLabel = title && title.trim().length > 0 ? title.trim() : 'sem titulo';
                        const message = normalizedStatus === 'approved'
                            ? `Seu imovel "${propertyLabel}" foi aprovado e ja esta disponivel no app.`
                            : `Seu imovel "${propertyLabel}" foi rejeitado. Revise as informacoes e tente novamente.`;
                        const role = await (0, userNotificationService_1.resolveUserNotificationRole)(ownerId);
                        await (0, userNotificationService_1.notifyUsers)({
                            message,
                            recipientIds: [ownerId],
                            recipientRole: role,
                            relatedEntityType: 'property',
                            relatedEntityId: propertyId,
                        });
                    }
                }
                catch (notifyError) {
                    console.error('Erro ao notificar usuario sobre status do imovel:', notifyError);
                }
            }
            return res.status(200).json({
                message: 'Status do imovel atualizado com sucesso.',
                status: normalizedStatus,
            });
        }
        catch (error) {
            console.error('Erro ao atualizar status do imovel:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async addPropertyImage(req, res) {
        const propertyId = Number(req.params.id);
        const files = req.files;
        if (Number.isNaN(propertyId)) {
            return res.status(400).json({ error: 'Identificador de imovel invalido.' });
        }
        if (!files || files.length === 0) {
            return res.status(400).json({ error: 'Nenhuma imagem enviada.' });
        }
        try {
            const [propertyRows] = await connection_1.default.query('SELECT id FROM properties WHERE id = ?', [propertyId]);
            if (propertyRows.length === 0) {
                return res.status(404).json({ error: 'Imovel nao encontrado.' });
            }
            const [imageCountRows] = await connection_1.default.query('SELECT COUNT(*) AS total FROM property_images WHERE property_id = ?', [propertyId]);
            const existingCount = Number(imageCountRows[0]?.total ?? 0);
            const availableSlots = Math.max(0, MAX_IMAGES_PER_PROPERTY - existingCount);
            if (availableSlots <= 0) {
                return res.status(400).json({
                    error: `Limite maximo de ${MAX_IMAGES_PER_PROPERTY} imagens por imovel atingido.`,
                });
            }
            if (files.length > availableSlots) {
                return res.status(400).json({
                    error: `Este imovel aceita somente ${availableSlots} nova(s) imagem(ns).`,
                });
            }
            const uploadedUrls = await uploadImagesWithConcurrency(files, 'properties/admin');
            if (uploadedUrls.length > 0) {
                const values = uploadedUrls.map((url) => [propertyId, url]);
                await connection_1.default.query('INSERT INTO property_images (property_id, image_url) VALUES ?', [values]);
            }
            return res.status(201).json({ message: 'Imagens adicionadas com sucesso.', images: uploadedUrls });
        }
        catch (error) {
            console.error('Erro ao adicionar imagens:', error);
            const knownError = error;
            if (knownError?.statusCode === 413) {
                return res.status(413).json({
                    error: 'Arquivo muito grande. Reduza o tamanho da imagem e tente novamente.',
                });
            }
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async deletePropertyImage(req, res) {
        const propertyId = Number(req.params.id);
        const imageId = Number(req.params.imageId);
        if (Number.isNaN(propertyId) || Number.isNaN(imageId)) {
            return res.status(400).json({ error: 'Identificadores invalidos.' });
        }
        try {
            const [imageCountRows] = await connection_1.default.query('SELECT COUNT(*) AS total FROM property_images WHERE property_id = ?', [propertyId]);
            const totalImages = Number(imageCountRows[0]?.total ?? 0);
            if (totalImages <= 1) {
                return res.status(400).json({ error: 'O imóvel precisa manter ao menos 1 imagem.' });
            }
            const [result] = await connection_1.default.query('DELETE FROM property_images WHERE id = ? AND property_id = ?', [imageId, propertyId]);
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Imagem nao encontrada para este imovel.' });
            }
            return res.status(200).json({ message: 'Imagem removida com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao remover imagem:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async addPropertyVideo(req, res) {
        const propertyId = Number(req.params.id);
        const file = req.file;
        if (Number.isNaN(propertyId)) {
            return res.status(400).json({ error: 'Identificador de imovel invalido.' });
        }
        if (!file) {
            return res.status(400).json({ error: 'Nenhum video enviado.' });
        }
        try {
            const [propertyRows] = await connection_1.default.query('SELECT id FROM properties WHERE id = ?', [propertyId]);
            if (propertyRows.length === 0) {
                return res.status(404).json({ error: 'Imovel nao encontrado.' });
            }
            const uploaded = await (0, cloudinary_1.uploadToCloudinary)(file, 'videos');
            await connection_1.default.query('UPDATE properties SET video_url = ? WHERE id = ?', [uploaded.url, propertyId]);
            return res.status(201).json({ message: 'Video adicionado com sucesso.', video: uploaded.url });
        }
        catch (error) {
            console.error('Erro ao adicionar video:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async deletePropertyVideo(req, res) {
        const propertyId = Number(req.params.id);
        if (Number.isNaN(propertyId)) {
            return res.status(400).json({ error: 'Identificador de imovel invalido.' });
        }
        try {
            const [result] = await connection_1.default.query('UPDATE properties SET video_url = NULL WHERE id = ?', [propertyId]);
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Imovel nao encontrado.' });
            }
            return res.status(200).json({ message: 'Video removido com sucesso.' });
        }
        catch (error) {
            console.error('Erro ao remover video:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async getBrokerProperties(req, res) {
        const brokerId = Number(req.params.id);
        if (Number.isNaN(brokerId)) {
            return res.status(400).json({ error: 'Identificador de corretor invalido.' });
        }
        try {
            const [properties] = await connection_1.default.query(`
          SELECT
            p.id,
            p.title,
            p.status,
            p.type,
            p.purpose,
            p.price,
            p.price_sale,
            p.price_rent,
            p.promotion_price,
            p.promotional_rent_price,
            p.promotional_rent_percentage,
            p.address,
            p.city,
            p.state,
            p.created_at
          FROM properties p
          WHERE p.broker_id = ?
          ORDER BY p.created_at DESC
        `, [brokerId]);
            return res.status(200).json({ data: properties });
        }
        catch (error) {
            console.error('Erro ao buscar imoveis do corretor:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async getClientProperties(req, res) {
        const clientId = Number(req.params.id);
        if (Number.isNaN(clientId)) {
            return res.status(400).json({ error: 'Identificador de cliente invalido.' });
        }
        try {
            const [properties] = await connection_1.default.query(`
          SELECT
            p.id,
            p.title,
            p.status,
            p.type,
            p.purpose,
            p.price,
            p.price_sale,
            p.price_rent,
            p.promotion_price,
            p.promotional_rent_price,
            p.promotional_rent_percentage,
            p.address,
            p.city,
            p.state,
            p.created_at
          FROM properties p
          WHERE p.owner_id = ?
          ORDER BY p.created_at DESC
        `, [clientId]);
            return res.status(200).json({ data: properties });
        }
        catch (error) {
            console.error('Erro ao buscar imoveis do cliente:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async getNotifications(req, res) {
        const adminId = Number(req.userId);
        if (!adminId) {
            return res.status(401).json({ error: 'Administrador nao autenticado.' });
        }
        try {
            const page = Math.max(parseInt(String(req.query.page ?? '1'), 10) || 1, 1);
            const limit = Math.min(Math.max(parseInt(String(req.query.limit ?? '20'), 10) || 20, 1), 100);
            const offset = (page - 1) * limit;
            const rawType = String(req.query.type ?? '').trim();
            const allowedTypes = new Set([
                'property',
                'broker',
                'agency',
                'user',
                'announcement',
                'negotiation',
                'other',
            ]);
            const typeFilter = allowedTypes.has(rawType) ? rawType : null;
            const baseParams = [adminId];
            let typeClause = '';
            if (typeFilter) {
                typeClause = ' AND related_entity_type = ?';
                baseParams.push(typeFilter);
            }
            const [rows] = await connection_1.default.query(`
          SELECT
            id,
            title,
            message,
            related_entity_type,
            related_entity_id,
            metadata_json,
            is_read,
            created_at
          FROM notifications
          WHERE recipient_id = ?
            AND recipient_type = 'admin'
            ${typeClause}
          ORDER BY created_at DESC
          LIMIT ? OFFSET ?
        `, [...baseParams, limit, offset]);
            const [countRows] = await connection_1.default.query(`
          SELECT COUNT(*) as total
          FROM notifications
          WHERE recipient_id = ?
            AND recipient_type = 'admin'
            ${typeClause}
        `, baseParams);
            const total = countRows.length > 0 ? Number(countRows[0].total) : 0;
            return res.status(200).json({ data: rows, total, page, limit });
        }
        catch (error) {
            console.error('Erro ao buscar notificacoes:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async deleteNotification(req, res) {
        const adminId = Number(req.userId);
        const notificationId = Number(req.params.id);
        if (!adminId) {
            return res.status(401).json({ error: 'Administrador nao autenticado.' });
        }
        if (Number.isNaN(notificationId)) {
            return res.status(400).json({ error: 'Identificador de notificacao invalido.' });
        }
        try {
            const [result] = await connection_1.default.query("DELETE FROM notifications WHERE id = ? AND recipient_id = ? AND recipient_type = 'admin'", [notificationId, adminId]);
            if (result.affectedRows === 0) {
                return res.status(404).json({ error: 'Notificacao nao encontrada.' });
            }
            return res.status(204).send();
        }
        catch (error) {
            console.error('Erro ao deletar notificacao:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
    async clearNotifications(req, res) {
        const adminId = Number(req.userId);
        if (!adminId) {
            return res.status(401).json({ error: 'Administrador nao autenticado.' });
        }
        try {
            await connection_1.default.query("DELETE FROM notifications WHERE recipient_id = ? AND recipient_type = 'admin'", [adminId]);
            return res.status(204).send();
        }
        catch (error) {
            console.error('Erro ao limpar notificacoes:', error);
            return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
        }
    }
}
/**
 * Busca estatisticas agregadas para o dashboard do admin.
 */
const getDashboardStats = async (req, res) => {
    try {
        const propertiesByStatusQuery = `
      SELECT
        status,
        COUNT(*) AS count
      FROM properties
      GROUP BY status
    `;
        const newPropertiesQuery = `
      SELECT
        DATE(created_at) AS date,
        COUNT(*) AS count
      FROM properties
      WHERE created_at >= CURDATE() - INTERVAL 30 DAY
      GROUP BY DATE(created_at)
      ORDER BY date ASC
    `;
        const totalsQuery = `
      SELECT
        (SELECT COUNT(*) FROM properties) AS totalProperties,
        (SELECT COUNT(*) FROM brokers) AS totalBrokers,
        (SELECT COUNT(*) FROM users) AS totalUsers
    `;
        const [propertiesByStatusResult, newPropertiesResult, totalsResult] = await Promise.all([
            connection_1.default.query(propertiesByStatusQuery),
            connection_1.default.query(newPropertiesQuery),
            connection_1.default.query(totalsQuery),
        ]);
        const [propertiesByStatusRows] = propertiesByStatusResult;
        const [newPropertiesRows] = newPropertiesResult;
        const [totalsRow] = totalsResult;
        const totals = Array.isArray(totalsRow) && totalsRow[0] ? totalsRow[0] : null;
        return res.status(200).json({
            totalProperties: Number(totals?.totalProperties ?? 0),
            totalBrokers: Number(totals?.totalBrokers ?? 0),
            totalUsers: Number(totals?.totalUsers ?? 0),
            propertiesByStatus: propertiesByStatusRows ?? [],
            newPropertiesOverTime: newPropertiesRows ?? [],
        });
    }
    catch (error) {
        console.error('Erro ao buscar estatisticas do dashboard:', error);
        return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
};
exports.getDashboardStats = getDashboardStats;
async function sendNotification(req, res) {
    try {
        const { message, recipientId, recipientIds, related_entity_type, related_entity_id, audience, } = req.body;
        if (!message || typeof message !== 'string' || message.trim() === '') {
            return res.status(400).json({ error: 'A mensagem e obrigatoria.' });
        }
        const trimmedMessage = message.trim();
        const allowedTypes = new Set(['property', 'broker', 'agency', 'user', 'announcement', 'negotiation', 'other']);
        const rawEntityType = String(related_entity_type);
        const entityType = (allowedTypes.has(rawEntityType) ? rawEntityType : 'other');
        const entityId = related_entity_id != null ? Number(related_entity_id) : null;
        const audienceValue = typeof audience === 'string' ? audience.trim().toLowerCase() : 'all';
        const normalizedAudience = audienceValue === 'client' || audienceValue === 'broker' ? audienceValue : 'all';
        const normalizedRecipients = [];
        if (Array.isArray(recipientIds)) {
            for (const rid of recipientIds) {
                const parsed = rid === null || rid === 'all' ? null : Number(rid);
                if (parsed === null || Number.isFinite(parsed)) {
                    normalizedRecipients.push(parsed === null ? null : Number(parsed));
                }
            }
        }
        else if (recipientId !== undefined) {
            const parsed = recipientId === null || recipientId === 'all' ? null : Number(recipientId);
            if (parsed === null || Number.isFinite(parsed)) {
                normalizedRecipients.push(parsed === null ? null : Number(parsed));
            }
        }
        if (normalizedRecipients.length === 0) {
            normalizedRecipients.push(null);
        }
        const sendToAll = normalizedRecipients.some((rid) => rid === null);
        let notificationRecipients = [];
        if (sendToAll) {
            if (normalizedAudience === 'broker') {
                const [userRows] = await connection_1.default.query("SELECT id FROM brokers WHERE status IN ('pending_verification','approved')");
                notificationRecipients = (userRows ?? [])
                    .map((row) => Number(row.id))
                    .filter((id) => Number.isFinite(id));
            }
            else if (normalizedAudience === 'client') {
                const [userRows] = await connection_1.default.query(`
            SELECT u.id
            FROM users u
            LEFT JOIN brokers b ON u.id = b.id
            WHERE b.id IS NULL OR b.status IN ('rejected')
          `);
                notificationRecipients = (userRows ?? [])
                    .map((row) => Number(row.id))
                    .filter((id) => Number.isFinite(id));
            }
            else {
                const [userRows] = await connection_1.default.query('SELECT id FROM users');
                notificationRecipients = (userRows ?? [])
                    .map((row) => Number(row.id))
                    .filter((id) => Number.isFinite(id));
            }
        }
        else {
            notificationRecipients = normalizedRecipients.filter((rid) => typeof rid === 'number');
        }
        if (notificationRecipients.length === 0) {
            return res.status(404).json({ error: 'Nenhum destinatario encontrado.' });
        }
        const { clientIds, brokerIds } = await (0, userNotificationService_1.splitRecipientsByRole)(notificationRecipients);
        const targetClientIds = normalizedAudience === 'broker' ? [] : clientIds;
        const targetBrokerIds = normalizedAudience === 'client' ? [] : brokerIds;
        const summaries = [];
        if (targetClientIds.length > 0) {
            const summary = await (0, userNotificationService_1.notifyUsers)({
                message: trimmedMessage,
                recipientIds: targetClientIds,
                recipientRole: 'client',
                relatedEntityType: entityType,
                relatedEntityId: entityId,
            });
            if (summary) {
                summaries.push(summary);
            }
        }
        if (targetBrokerIds.length > 0) {
            const summary = await (0, userNotificationService_1.notifyUsers)({
                message: trimmedMessage,
                recipientIds: targetBrokerIds,
                recipientRole: 'broker',
                relatedEntityType: entityType,
                relatedEntityId: entityId,
            });
            if (summary) {
                summaries.push(summary);
            }
        }
        if (summaries.length === 0) {
            return res.status(404).json({ error: 'Nenhum destinatario encontrado.' });
        }
        const errorCodes = new Set();
        const combined = {
            requested: 0,
            success: 0,
            failure: 0,
            errorCodes: [],
        };
        for (const summary of summaries) {
            combined.requested += summary.requested;
            combined.success += summary.success;
            combined.failure += summary.failure;
            for (const code of summary.errorCodes) {
                errorCodes.add(code);
            }
        }
        combined.errorCodes = Array.from(errorCodes);
        return res
            .status(201)
            .json({ message: 'Notificacao enviada com sucesso.', push: combined });
    }
    catch (error) {
        console.error('Erro ao enviar notificacao:', error);
        return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
}
exports.adminController = new AdminController();
