"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authController = void 0;
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const crypto_1 = __importDefault(require("crypto"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const firebaseAdmin_1 = __importDefault(require("../config/firebaseAdmin"));
const env_1 = require("../config/env");
const connection_1 = __importDefault(require("../database/connection"));
const phoneOtpService_1 = require("../services/phoneOtpService");
const address_1 = require("../utils/address");
const creci_1 = require("../utils/creci");
const jwtSecret = (0, env_1.requireEnv)('JWT_SECRET');
function buildBrokerPayload(row) {
    const hasBrokerData = row?.broker_id != null ||
        row?.broker_status != null ||
        row?.creci != null;
    if (!hasBrokerData) {
        return null;
    }
    return {
        id: Number(row.broker_id ?? row.id),
        status: row.broker_status != null ? String(row.broker_status) : null,
        creci: row.creci != null ? String(row.creci) : null,
    };
}
function buildUserPayload(row, profileType) {
    const broker = buildBrokerPayload(row);
    return {
        id: row.id,
        name: row.name,
        email: row.email,
        phone: row.phone ?? null,
        street: row.street ?? null,
        number: row.number ?? null,
        complement: row.complement ?? null,
        bairro: row.bairro ?? null,
        city: row.city ?? null,
        state: row.state ?? null,
        cep: row.cep ?? null,
        role: profileType,
        broker_status: row.broker_status ?? null,
        broker,
    };
}
function hasCompleteProfile(row) {
    return !!(row.phone &&
        row.street &&
        row.number &&
        row.bairro &&
        row.city &&
        row.state &&
        row.cep);
}
function signToken(id, role) {
    return jsonwebtoken_1.default.sign({ id, role }, jwtSecret, { expiresIn: '7d' });
}
function hashResetCode(code) {
    return crypto_1.default.createHash('sha256').update(code).digest('hex');
}
function generateResetCode() {
    const number = crypto_1.default.randomInt(100000, 1000000);
    return String(number);
}
function withTimeout(promise, ms, label) {
    return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
            reject(new Error(`Timeout while waiting for ${label}`));
        }, ms);
        promise
            .then((value) => {
            clearTimeout(timer);
            resolve(value);
        })
            .catch((error) => {
            clearTimeout(timer);
            reject(error);
        });
    });
}
class AuthController {
    normalizePhoneOtpInput(value) {
        return String(value ?? '').replace(/\D/g, '');
    }
    buildOtpIssueResponse(issue) {
        const base = {
            sessionToken: issue.sessionToken,
            expiresAt: issue.expiresAt.toISOString(),
        };
        if (process.env.NODE_ENV === 'test') {
            return {
                ...base,
                otpCode: issue.code,
            };
        }
        return base;
    }
    async requestOtp(req, res) {
        const phone = this.normalizePhoneOtpInput(req.body?.phone);
        if (phone.length < 8) {
            return res.status(400).json({ error: 'Telefone invalido.' });
        }
        const issue = phoneOtpService_1.phoneOtpService.requestOtp(phone);
        return res.status(200).json(this.buildOtpIssueResponse(issue));
    }
    async resendOtp(req, res) {
        const sessionToken = String(req.body?.sessionToken ?? '').trim();
        if (!sessionToken) {
            return res.status(400).json({ error: 'sessionToken e obrigatorio.' });
        }
        const issue = phoneOtpService_1.phoneOtpService.resendOtp(sessionToken);
        if (!issue) {
            return res.status(404).json({ error: 'Sessao OTP nao encontrada.' });
        }
        return res.status(200).json(this.buildOtpIssueResponse(issue));
    }
    async verifyOtp(req, res) {
        const sessionToken = String(req.body?.sessionToken ?? '').trim();
        const code = String(req.body?.code ?? '').replace(/\D/g, '');
        if (!sessionToken || code.length !== 6) {
            return res.status(400).json({ error: 'sessionToken e codigo sao obrigatorios.' });
        }
        const result = phoneOtpService_1.phoneOtpService.verifyOtp(sessionToken, code);
        if (!result.ok) {
            return res.status(400).json({ error: 'Codigo invalido ou expirado.' });
        }
        return res.status(200).json({ ok: true });
    }
    async checkEmail(req, res) {
        const email = String(req.query.email ?? req.body?.email ?? '').trim().toLowerCase();
        if (!email) {
            return res.status(400).json({ error: 'Email e obrigatorio.' });
        }
        try {
            const [rows] = await connection_1.default.query('SELECT id, firebase_uid, password_hash FROM users WHERE email = ? LIMIT 1', [email]);
            const exists = rows.length > 0;
            const hasFirebaseUid = exists && rows[0].firebase_uid != null;
            const hasPassword = exists && !!rows[0].password_hash;
            return res.status(200).json({ exists, hasFirebaseUid, hasPassword });
        }
        catch (error) {
            console.error('Erro ao verificar email:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async requestPasswordReset(req, res) {
        const email = String(req.body?.email ?? '').trim().toLowerCase();
        if (!email) {
            return res.status(400).json({ error: 'Email e obrigatorio.' });
        }
        try {
            // 1. Check if user exists in SQL
            const [rows] = await connection_1.default.query('SELECT id, name, firebase_uid FROM users WHERE email = ? LIMIT 1', [email]);
            if (rows.length === 0) {
                // Security: Don't reveal if user doesn't exist, but for now we follow existing pattern
                return res.status(404).json({ error: 'Email nao encontrado.' });
            }
            const user = rows[0];
            // 2. If user is Legacy (no firebase_uid), migrate them NOW.
            if (!user.firebase_uid) {
                try {
                    // Check if user already exists in Firebase (edge case: registered in Firebase but not linked in SQL)
                    let firebaseUser;
                    try {
                        firebaseUser = await firebaseAdmin_1.default.auth().getUserByEmail(email);
                    }
                    catch (e) {
                        if (e.code === 'auth/user-not-found') {
                            // Create user in Firebase
                            firebaseUser = await firebaseAdmin_1.default.auth().createUser({
                                email: email,
                                emailVerified: true, // We trust our SQL verification or just assume true for legacy
                                displayName: user.name,
                            });
                        }
                        else {
                            throw e;
                        }
                    }
                    // Update SQL with new UID
                    await connection_1.default.query('UPDATE users SET firebase_uid = ? WHERE id = ?', [firebaseUser.uid, user.id]);
                    console.log(`[Migration] User ${user.id} migrated to Firebase UID ${firebaseUser.uid}`);
                }
                catch (migrationError) {
                    console.error('Erro na migracao para Firebase:', migrationError);
                    return res.status(500).json({ error: 'Erro ao preparar conta para recuperacao.' });
                }
            }
            // 3. Respond OK so Frontend can trigger the Firebase SDK email
            return res.status(200).json({ message: 'Usuario pronto para reset via Firebase.' });
        }
        catch (error) {
            console.error('Erro ao solicitar reset de senha:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    // confirmPasswordReset deprecated/removed as Firebase handles the UI.
    async verifyPhone(req, res) {
        const email = String(req.body?.email ?? '').trim().toLowerCase();
        if (!email) {
            return res.status(400).json({ error: 'Email e obrigatorio.' });
        }
        try {
            const [rows] = await connection_1.default.query(`
          SELECT
            u.id,
            u.name,
            u.email,
            u.phone,
            u.street,
            u.number,
            u.complement,
            u.bairro,
            u.city,
            u.state,
            u.cep,
            b.id AS broker_id,
            b.status AS broker_status,
            b.creci AS creci
          FROM users u
          LEFT JOIN brokers b ON u.id = b.id
          WHERE u.email = ?
          LIMIT 1
        `, [email]);
            if (rows.length === 0) {
                return res.status(404).json({ error: 'Usuario nao encontrado.' });
            }
            const row = rows[0];
            const brokerStatus = String(row.broker_status ?? '').trim();
            const profile = row.broker_id != null &&
                (brokerStatus === 'approved' || brokerStatus === 'pending_verification')
                ? 'broker'
                : 'client';
            const userPayload = buildUserPayload(row, profile);
            return res.status(200).json({
                user: userPayload,
                broker: userPayload.broker,
                needsCompletion: !hasCompleteProfile(row),
            });
        }
        catch (error) {
            console.error('Erro ao verificar telefone:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async register(req, res) {
        const { name, email, password, phone, street, number, complement, bairro, city, state, cep, profileType, creci, } = req.body;
        if (!name || !email || !password) {
            return res.status(400).json({ error: 'Nome, email e senha s??o obrigat??rios.' });
        }
        const normalizedProfile = profileType === 'broker' ? 'broker' : 'client';
        const brokerCreci = (0, creci_1.normalizeCreci)(creci);
        if (normalizedProfile === 'broker' && !(0, creci_1.hasValidCreci)(brokerCreci)) {
            return res.status(400).json({
                error: 'CRECI invalido. Use 4 a 6 numeros com sufixo opcional (ex: 12345-F).',
            });
        }
        try {
            const [existingUserRows] = await connection_1.default.query('SELECT id FROM users WHERE email = ?', [email]);
            if (existingUserRows.length > 0) {
                return res.status(409).json({ error: 'Este email já está em uso.' });
            }
            const addressResult = (0, address_1.sanitizeAddressInput)({
                street,
                number,
                complement,
                bairro,
                city,
                state,
                cep,
            });
            if (!addressResult.ok) {
                return res.status(400).json({
                    error: 'Endereco incompleto ou invalido.',
                    fields: addressResult.errors,
                });
            }
            const passwordHash = await bcryptjs_1.default.hash(password, 8);
            const [userResult] = await connection_1.default.query(`
          INSERT INTO users (name, email, password_hash, phone, street, number, complement, bairro, city, state, cep)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
                name,
                email,
                passwordHash,
                phone ?? null,
                addressResult.value.street,
                addressResult.value.number,
                addressResult.value.complement,
                addressResult.value.bairro,
                addressResult.value.city,
                addressResult.value.state,
                addressResult.value.cep,
            ]);
            const userId = userResult.insertId;
            if (normalizedProfile === 'broker') {
                await connection_1.default.query('INSERT INTO brokers (id, creci, status) VALUES (?, ?, ?)', [userId, brokerCreci, 'pending_verification']);
            }
            const token = signToken(userId, normalizedProfile);
            const userPayload = buildUserPayload({
                id: userId,
                name,
                email,
                phone,
                street: addressResult.value.street,
                number: addressResult.value.number,
                complement: addressResult.value.complement,
                bairro: addressResult.value.bairro,
                city: addressResult.value.city,
                state: addressResult.value.state,
                cep: addressResult.value.cep,
                broker_id: normalizedProfile === 'broker' ? userId : null,
                broker_status: normalizedProfile === 'broker' ? 'pending_verification' : null,
                creci: normalizedProfile === 'broker' ? brokerCreci : null,
            }, normalizedProfile);
            return res.status(201).json({
                user: userPayload,
                broker: userPayload.broker,
                token,
                needsCompletion: !hasCompleteProfile({
                    phone,
                    street: addressResult.value.street,
                    number: addressResult.value.number,
                    bairro: addressResult.value.bairro,
                    city: addressResult.value.city,
                    state: addressResult.value.state,
                    cep: addressResult.value.cep,
                }),
                requiresDocuments: normalizedProfile === 'broker',
            });
        }
        catch (error) {
            console.error('Erro no registro:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async login(req, res) {
        const { email, password } = req.body;
        if (!email || !password) {
            return res.status(400).json({ error: 'Email e senha são obrigatórios.' });
        }
        try {
            const [rows] = await connection_1.default.query(`
          SELECT u.id, u.name, u.email, u.password_hash, u.phone, u.street, u.number, u.complement, u.bairro, u.city, u.state, u.cep,
                 CASE
                   WHEN b.id IS NOT NULL AND b.status IN ('approved', 'pending_verification') THEN 'broker'
                   ELSE 'client'
                 END AS role,
                 b.id AS broker_id,
                 b.status AS broker_status,
                 b.creci AS creci,
                 bd.status AS broker_documents_status
          FROM users u
          LEFT JOIN brokers b ON u.id = b.id
          LEFT JOIN broker_documents bd ON b.id = bd.broker_id
          WHERE u.email = ?
        `, [email]);
            if (rows.length === 0) {
                return res.status(401).json({ error: 'Credenciais inválidas.' });
            }
            const user = rows[0];
            const isPasswordCorrect = await bcryptjs_1.default.compare(password, String(user.password_hash));
            if (!isPasswordCorrect) {
                return res.status(401).json({ error: 'Credenciais inválidas.' });
            }
            const profile = user.role === 'broker' ? 'broker' : 'client';
            const brokerDocsStatus = String(user.broker_documents_status ?? '').trim().toLowerCase();
            const requiresDocuments = profile === 'broker' && (brokerDocsStatus.length === 0 || brokerDocsStatus == 'rejected');
            const token = signToken(user.id, profile);
            return res.json({
                user: buildUserPayload(user, profile),
                token,
                needsCompletion: !hasCompleteProfile(user),
                requiresDocuments,
            });
        }
        catch (error) {
            console.error('Erro no login:', error);
            return res.status(500).json({ error: 'Erro interno do servidor.' });
        }
    }
    async google(req, res) {
        const { idToken, profileType } = req.body;
        if (!idToken) {
            return res.status(400).json({ error: 'idToken do Google é obrigatório.' });
        }
        const requestedProfile = profileType === 'broker' ? 'broker' : profileType === 'client' ? 'client' : 'auto';
        const autoMode = requestedProfile === 'auto';
        try {
            const decoded = await withTimeout(firebaseAdmin_1.default.auth().verifyIdToken(idToken), 8000, 'firebase token verification');
            const uid = decoded.uid;
            const email = decoded.email;
            const displayName = decoded.name || decoded.email?.split('@')[0] || `User-${uid}`;
            if (!email) {
                return res.status(400).json({ error: 'Email não disponível no token do Google.' });
            }
            const [existingRows] = await connection_1.default.query(`SELECT u.id, u.name, u.email, u.phone, u.street, u.number, u.complement, u.bairro, u.city, u.state, u.cep, u.firebase_uid,
                b.id AS broker_id, b.status AS broker_status, b.creci AS creci,
                bd.status AS broker_documents_status
           FROM users u
           LEFT JOIN brokers b ON u.id = b.id
           LEFT JOIN broker_documents bd ON u.id = bd.broker_id
          WHERE u.firebase_uid = ? OR u.email = ?
          LIMIT 1`, [uid, email]);
            let userId;
            let userName = displayName;
            let phone = null;
            let street = null;
            let number = null;
            let complement = null;
            let bairro = null;
            let city = null;
            let state = null;
            let cep = null;
            let hasBrokerRow = false;
            let createdNow = false;
            let blockedBrokerRequest = false;
            let effectiveProfile = 'client';
            let requiresDocuments = false;
            let roleLocked = false;
            let brokerStatus = null;
            let brokerDocumentsStatus = null;
            let hasBrokerDocuments = false;
            if (existingRows.length > 0) {
                const row = existingRows[0];
                userId = row.id;
                userName = row.name || displayName;
                phone = row.phone ?? null;
                street = row.street ?? null;
                number = row.number ?? null;
                complement = row.complement ?? null;
                bairro = row.bairro ?? null;
                city = row.city ?? null;
                state = row.state ?? null;
                cep = row.cep ?? null;
                hasBrokerRow = !!row.broker_id;
                brokerStatus = row.broker_status ?? null;
                brokerDocumentsStatus = row.broker_documents_status ?? null;
                hasBrokerDocuments = brokerDocumentsStatus != null;
                blockedBrokerRequest =
                    brokerStatus === 'rejected';
                if (hasBrokerRow && !blockedBrokerRequest) {
                    effectiveProfile = 'broker';
                }
                else {
                    effectiveProfile = 'client';
                    requiresDocuments = hasBrokerRow;
                }
                if (!row.firebase_uid) {
                    await connection_1.default.query('UPDATE users SET firebase_uid = ? WHERE id = ?', [uid, userId]);
                }
            }
            else {
                if (autoMode) {
                    return res.json({
                        requiresProfileChoice: true,
                        pending: { email, name: displayName },
                        isNewUser: true,
                        roleLocked: false,
                        needsCompletion: true,
                        requiresDocuments: false,
                    });
                }
                const [result] = await connection_1.default.query('INSERT INTO users (firebase_uid, email, name) VALUES (?, ?, ?)', [uid, email, displayName]);
                userId = result.insertId;
                createdNow = true;
                effectiveProfile = requestedProfile === 'broker' ? 'broker' : 'client';
                if (requestedProfile === 'broker') {
                    await connection_1.default.query('INSERT INTO brokers (id, creci, status) VALUES (?, ?, ?)', [userId, null, 'pending_verification']);
                    brokerStatus = 'pending_verification';
                    hasBrokerRow = true;
                    requiresDocuments = true;
                }
            }
            if (!autoMode && requestedProfile === 'broker') {
                if (blockedBrokerRequest) {
                    effectiveProfile = 'client';
                    roleLocked = true;
                    requiresDocuments = true;
                }
                else {
                    effectiveProfile = 'broker';
                    roleLocked = false;
                    if (!hasBrokerRow) {
                        await connection_1.default.query('INSERT INTO brokers (id, creci, status) VALUES (?, ?, ?)', [userId, null, 'pending_verification']);
                        brokerStatus = 'pending_verification';
                        hasBrokerRow = true;
                    }
                    requiresDocuments = (brokerStatus ?? '') !== 'approved';
                }
            }
            else if (!autoMode && requestedProfile === 'client') {
                effectiveProfile = blockedBrokerRequest ? 'client' : effectiveProfile;
                roleLocked = blockedBrokerRequest;
            }
            else if (autoMode) {
                roleLocked = blockedBrokerRequest || effectiveProfile === 'broker';
                requiresDocuments =
                    effectiveProfile === 'broker' && (brokerStatus ?? '') !== 'approved';
                if (effectiveProfile === 'broker' && blockedBrokerRequest) {
                    effectiveProfile = 'client';
                }
            }
            const needsCompletion = !hasCompleteProfile({ phone, street, number, bairro, city, state, cep });
            const brokerDocsRequired = effectiveProfile === 'broker' &&
                (!hasBrokerDocuments || brokerDocumentsStatus === 'rejected');
            requiresDocuments = brokerDocsRequired;
            const token = signToken(userId, effectiveProfile);
            return res.json({
                user: buildUserPayload({
                    id: userId,
                    name: userName,
                    email,
                    phone,
                    street,
                    number,
                    complement,
                    bairro,
                    city,
                    state,
                    cep,
                    broker_status: brokerStatus,
                }, effectiveProfile),
                token,
                needsCompletion,
                requiresDocuments,
                blockedBrokerRequest,
                roleLocked,
                isNewUser: createdNow,
            });
        }
        catch (error) {
            console.error('Google auth error:', error);
            const details = error?.sqlMessage || error?.message || String(error);
            const message = String(details).toLowerCase();
            const status = message.includes('timeout') ? 504 : 500;
            return res.status(status).json({
                error: 'Erro ao autenticar com Google.',
                details,
            });
        }
    }
}
exports.authController = new AuthController();
