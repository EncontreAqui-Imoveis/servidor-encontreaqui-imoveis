import { Request, Response } from "express";
import { RowDataPacket, ResultSetHeader } from "mysql2";
import connection from "../database/connection";
import { uploadToCloudinary } from "../config/cloudinary";
import AuthRequest from "../middlewares/auth";
import { notifyAdmins } from "../services/notificationService";
import {
  notifyPriceDropIfNeeded,
  notifyPromotionStarted,
} from "../services/priceDropNotificationService";
import { normalizePropertyType } from "../utils/propertyTypes";

interface MulterFiles {
  [fieldname: string]: Express.Multer.File[];
}

export interface AuthRequestWithFiles extends AuthRequest {
  files?: MulterFiles;
}
type PropertyStatus = "pending_approval" | "approved" | "rejected" | "rented" | "sold";
type DealType = "sale" | "rent";
type RecurrenceInterval = "none" | "weekly" | "monthly" | "yearly";

type Nullable<T> = T | null;

const STATUS_MAP: Record<string, PropertyStatus> = {
  pendingapproval: "pending_approval",
  pendente: "pending_approval",
  pending: "pending_approval",
  pendenteaprovacao: "pending_approval",
  aprovado: "approved",
  approved: "approved",
  aprovada: "approved",
  rejected: "rejected",
  rejeitado: "rejected",
  rejeitada: "rejected",
  rented: "rented",
  alugado: "rented",
  alugada: "rented",
  locado: "rented",
  locada: "rented",
  sold: "sold",
  vendido: "sold",
  vendida: "sold",
};

const ALLOWED_STATUSES = new Set<PropertyStatus>([
  "pending_approval",
  "approved",
  "rejected",
  "rented",
  "sold",
]);

const MAX_IMAGES_PER_PROPERTY = 20;

const NOTIFY_ON_STATUS: Set<PropertyStatus> = new Set(["sold", "rented"]);

const DEAL_TYPE_MAP: Record<string, DealType> = {
  sale: "sale",
  sold: "sale",
  venda: "sale",
  vendido: "sale",
  vendida: "sale",
  rent: "rent",
  rented: "rent",
  aluguel: "rent",
  alugado: "rent",
  alugada: "rent",
  locacao: "rent",
  locado: "rent",
  locada: "rent",
};

const STATUS_TO_DEAL: Partial<Record<PropertyStatus, DealType>> = {
  sold: "sale",
  rented: "rent",
};

const PURPOSE_MAP: Record<string, string> = {
  venda: "Venda",
  comprar: "Venda",
  aluguel: "Aluguel",
  alugar: "Aluguel",
  vendaealuguel: "Venda e Aluguel",
  vendaaluguel: "Venda e Aluguel",
};

const ALLOWED_PURPOSES = new Set(["Venda", "Aluguel", "Venda e Aluguel"]);

const RECURRENCE_INTERVALS = new Set<RecurrenceInterval>([
  "none",
  "weekly",
  "monthly",
  "yearly",
]);

interface PropertyRow extends RowDataPacket {
  id: number;
  broker_id: number | null;
  owner_id?: number | null;
  owner_name?: string | null;
  owner_phone?: string | null;
  broker_name?: string | null;
  broker_phone?: string | null;
  broker_email?: string | null;
  title: string;
  description: string;
  type: string;
  purpose: string;
  status: PropertyStatus;
  visibility?: string | null;
  lifecycle_status?: string | null;
  is_promoted?: number | boolean | null;
  promotion_percentage?: number | string | null;
  promotion_start?: Date | string | null;
  promotion_end?: Date | string | null;
  promo_percentage?: number | string | null;
  promo_start_date?: Date | string | null;
  promo_end_date?: Date | string | null;
  promo_percentage_resolved?: number | string | null;
  promo_start_date_resolved?: Date | string | null;
  promo_end_date_resolved?: Date | string | null;
  price: number | string;
  price_sale?: number | string | null;
  price_rent?: number | string | null;
  code?: string | null;
  address: string;
  quadra?: string | null;
  lote?: string | null;
  numero?: string | null;
  bairro?: string | null;
  complemento?: string | null;
  tipo_lote?: string | null;
  city: string;
  state: string;
  cep?: string | null;
  bedrooms?: number | null;
  bathrooms?: number | null;
  area_construida?: number | string | null;
  area_terreno?: number | string | null;
  garage_spots?: number | null;
  has_wifi?: number | boolean | null;
  tem_piscina?: number | boolean | null;
  tem_energia_solar?: number | boolean | null;
  tem_automacao?: number | boolean | null;
  tem_ar_condicionado?: number | boolean | null;
  eh_mobiliada?: number | boolean | null;
  valor_condominio?: number | string | null;
  valor_iptu?: number | string | null;
  sale_value?: number | string | null;
  commission_rate?: number | string | null;
  commission_value?: number | string | null;
  video_url?: string | null;
  created_at?: Date;
  updated_at?: Date;
  images?: string | null;
  agency_id?: number | null;
  agency_name?: string | null;
  agency_logo_url?: string | null;
  agency_address?: string | null;
  agency_city?: string | null;
  agency_state?: string | null;
  agency_phone?: string | null;
}

interface PropertyAggregateRow extends PropertyRow {
  images?: string | null;
}

function normalizeStatus(value: unknown): Nullable<PropertyStatus> {
  if (typeof value !== "string") {
    return null;
  }
  const normalized = value
    .normalize("NFD")
    .replace(/[^\p{L}0-9]/gu, "")
    .toLowerCase();
  const status = STATUS_MAP[normalized];
  if (!status || !ALLOWED_STATUSES.has(status)) {
    return null;
  }
  return status;
}


function normalizePurpose(value: unknown): Nullable<string> {
  if (typeof value !== "string") {
    return null;
  }
  const normalized = value
    .normalize("NFD")
    .replace(/[^\p{L}0-9]/gu, "")
    .toLowerCase();
  const mapped = PURPOSE_MAP[normalized];
  if (!mapped || !ALLOWED_PURPOSES.has(mapped)) {
    return null;
  }
  return mapped;
}

function purposeAllowsDeal(purpose: string, dealType: DealType): boolean {
  const normalized = normalizePurpose(purpose) ?? purpose;
  const lower = normalized.toLowerCase();
  if (dealType === "sale") {
    return lower.includes("vend");
  }
  return lower.includes("alug");
}

function parseOptionalPrice(value: unknown): Nullable<number> {
  if (value === undefined || value === null || value === "") {
    return null;
  }
  return parsePrice(value);
}

function parsePrice(value: unknown): number {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed < 0) {
    throw new Error("Preço inválido.");
  }
  return parsed;
}

function normalizeDealType(value: unknown): Nullable<DealType> {
  if (typeof value !== "string") {
    return null;
  }
  const normalized = value
    .normalize("NFD")
    .replace(/[^\p{L}0-9]/gu, "")
    .toLowerCase();
  return DEAL_TYPE_MAP[normalized] ?? null;
}

function resolveDealTypeFromStatus(status: Nullable<PropertyStatus>): Nullable<DealType> {
  if (!status) return null;
  return STATUS_TO_DEAL[status] ?? null;
}

function normalizeRecurrenceInterval(
  value: unknown
): Nullable<RecurrenceInterval> {
  if (value === undefined || value === null || value === "") {
    return null;
  }
  if (typeof value !== "string") {
    return null;
  }
  const normalized = value.trim().toLowerCase() as RecurrenceInterval;
  return RECURRENCE_INTERVALS.has(normalized) ? normalized : null;
}

function resolveDealAmount(value: unknown, fallback: number): number {
  if (value === undefined || value === null || value === "") {
    return fallback;
  }
  return parsePrice(value);
}

function calculateCommissionAmount(amount: number, rate: number): number {
  return Number((amount * (rate / 100)).toFixed(2));
}

function parseDecimal(value: unknown): Nullable<number> {
  if (value === undefined || value === null || value === "") {
    return null;
  }
  const parsed = Number(value);
  if (!Number.isFinite(parsed)) {
    throw new Error("Valor numérico inválido.");
  }
  return parsed;
}

function parseInteger(value: unknown): Nullable<number> {
  if (value === undefined || value === null || value === "") {
    return null;
  }
  const parsed = Number(value);
  if (!Number.isFinite(parsed)) {
    throw new Error("Valor inteiro inválido.");
  }
  return Math.trunc(parsed);
}

function parseBoolean(value: unknown): 0 | 1 {
  if (typeof value === "boolean") {
    return value ? 1 : 0;
  }
  if (typeof value === "number") {
    return value === 0 ? 0 : 1;
  }
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    return ["1", "true", "yes", "sim", "on"].includes(normalized) ? 1 : 0;
  }
  return 0;
}

function parsePromotionPercentage(value: unknown): Nullable<number> {
  if (value === undefined || value === null || value === "") {
    return null;
  }
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0 || parsed > 100) {
    throw new Error("Percentual de promocao invalido. Use valor entre 0 e 100.");
  }
  return Number(parsed.toFixed(2));
}

function parsePromotionDateTime(value: unknown): Nullable<string> {
  if (value === undefined || value === null || value === "") {
    return null;
  }
  const parsed = new Date(String(value));
  if (Number.isNaN(parsed.getTime())) {
    throw new Error("Data de promocao invalida.");
  }
  return parsed.toISOString().slice(0, 19).replace("T", " ");
}

function parsePromotionDate(value: unknown): Nullable<string> {
  if (value === undefined || value === null || value === "") {
    return null;
  }
  const parsed = new Date(String(value));
  if (Number.isNaN(parsed.getTime())) {
    throw new Error("Data de promocao invalida.");
  }
  return parsed.toISOString().slice(0, 10);
}

function stringOrNull(value: unknown): Nullable<string> {
  if (value === undefined || value === null) {
    return null;
  }
  const str = String(value).trim();
  return str.length > 0 ? str : null;
}

function toBoolean(value: unknown): boolean {
  return value === 1 || value === "1" || value === true;
}

function mapProperty(row: PropertyAggregateRow, includeOwnerInfo = false) {
  const images = row.images ? row.images.split(",").filter(Boolean) : [];

  const agency = row.agency_id
    ? {
      id: Number(row.agency_id),
      name: row.agency_name,
      logo_url: row.agency_logo_url,
      address: row.agency_address,
      city: row.agency_city,
      state: row.agency_state,
      phone: row.agency_phone,
    }
    : null;

  return {
    id: row.id,
    title: row.title,
    description: row.description,
    type: row.type,
    purpose: row.purpose,
    status: row.status,
    visibility: row.visibility ?? 'PUBLIC',
    lifecycle_status: row.lifecycle_status ?? 'AVAILABLE',
    is_promoted: toBoolean(row.is_promoted),
    promotion_percentage:
      row.promo_percentage_resolved != null
        ? Number(row.promo_percentage_resolved)
        : row.promo_percentage != null
          ? Number(row.promo_percentage)
          : row.promotion_percentage != null
            ? Number(row.promotion_percentage)
            : null,
    promotion_start:
      row.promo_start_date_resolved ?? row.promo_start_date ?? row.promotion_start ?? null,
    promotion_end:
      row.promo_end_date_resolved ?? row.promo_end_date ?? row.promotion_end ?? null,
    promo_percentage:
      row.promo_percentage_resolved != null
        ? Number(row.promo_percentage_resolved)
        : row.promotion_percentage != null
          ? Number(row.promotion_percentage)
          : null,
    promo_start_date:
      row.promo_start_date_resolved ?? row.promo_start_date ?? row.promotion_start ?? null,
    promo_end_date:
      row.promo_end_date_resolved ?? row.promo_end_date ?? row.promotion_end ?? null,
    promoPercentage:
      row.promo_percentage_resolved != null
        ? Number(row.promo_percentage_resolved)
        : row.promotion_percentage != null
          ? Number(row.promotion_percentage)
          : null,
    promoStartDate:
      row.promo_start_date_resolved ?? row.promo_start_date ?? row.promotion_start ?? null,
    promoEndDate:
      row.promo_end_date_resolved ?? row.promo_end_date ?? row.promotion_end ?? null,
    price: Number(row.price),
    price_sale: row.price_sale != null ? Number(row.price_sale) : null,
    price_rent: row.price_rent != null ? Number(row.price_rent) : null,
    code: row.code ?? null,
    owner_name: includeOwnerInfo ? (row.owner_name ?? null) : null,
    owner_phone: includeOwnerInfo ? (row.owner_phone ?? null) : null,
    address: row.address,
    cep: row.cep ?? null,
    quadra: row.quadra ?? null,
    lote: row.lote ?? null,
    numero: row.numero ?? null,
    bairro: row.bairro ?? null,
    complemento: row.complemento ?? null,
    tipo_lote: row.tipo_lote ?? null,
    city: row.city,
    state: row.state,
    bedrooms: row.bedrooms != null ? Number(row.bedrooms) : null,
    bathrooms: row.bathrooms != null ? Number(row.bathrooms) : null,
    area_construida:
      row.area_construida != null ? Number(row.area_construida) : null,
    area_terreno: row.area_terreno != null ? Number(row.area_terreno) : null,
    garage_spots: row.garage_spots != null ? Number(row.garage_spots) : null,
    has_wifi: toBoolean(row.has_wifi),
    tem_piscina: toBoolean(row.tem_piscina),
    tem_energia_solar: toBoolean(row.tem_energia_solar),
    tem_automacao: toBoolean(row.tem_automacao),
    tem_ar_condicionado: toBoolean(row.tem_ar_condicionado),
    eh_mobiliada: toBoolean(row.eh_mobiliada),
    valor_condominio:
      row.valor_condominio != null ? Number(row.valor_condominio) : null,
    valor_iptu: row.valor_iptu != null ? Number(row.valor_iptu) : null,
    video_url: row.video_url ?? null,
    images,
    agency,
    broker_name: row.broker_name ?? null,
    broker_phone: row.broker_phone ?? null,
    broker_email: row.broker_email ?? null,
    created_at: row.created_at,
    updated_at: row.updated_at,
  };
}

type QueryExecutor = Pick<typeof connection, "query">;

async function upsertSaleRecord(
  db: QueryExecutor,
  payload: {
    propertyId: number;
    brokerId: number;
    dealType: DealType;
    salePrice: number;
    commissionRate: number;
    commissionAmount: number;
    iptuValue: number | null;
    condominioValue: number | null;
    isRecurring: number;
    commissionCycles: number;
    recurrenceInterval: RecurrenceInterval;
  }
) {
  const {
    propertyId,
    brokerId,
    dealType,
    salePrice,
    commissionRate,
    commissionAmount,
    iptuValue,
    condominioValue,
    isRecurring,
    commissionCycles,
    recurrenceInterval,
  } = payload;

  const [existingSaleRows] = await db.query<RowDataPacket[]>(
    "SELECT id FROM sales WHERE property_id = ? ORDER BY sale_date DESC LIMIT 1",
    [propertyId]
  );

  if (existingSaleRows.length > 0) {
    await db.query(
      `UPDATE sales
         SET deal_type = ?,
             sale_price = ?,
             commission_rate = ?,
             commission_amount = ?,
             iptu_value = ?,
             condominio_value = ?,
             is_recurring = ?,
             commission_cycles = ?,
             recurrence_interval = ?,
             sale_date = CURRENT_TIMESTAMP
       WHERE id = ?`,
      [
        dealType,
        salePrice,
        commissionRate,
        commissionAmount,
        iptuValue,
        condominioValue,
        isRecurring,
        commissionCycles,
        recurrenceInterval,
        existingSaleRows[0].id,
      ]
    );
    return;
  }

  await db.query(
    `INSERT INTO sales
       (property_id, broker_id, deal_type, sale_price, commission_rate, commission_amount, iptu_value, condominio_value, is_recurring, commission_cycles, recurrence_interval)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    [
      propertyId,
      brokerId,
      dealType,
      salePrice,
      commissionRate,
      commissionAmount,
      iptuValue,
      condominioValue,
      isRecurring,
      commissionCycles,
      recurrenceInterval,
    ]
  );
}

class PropertyController {
  async show(req: Request, res: Response) {
    const propertyId = Number(req.params.id);

    if (Number.isNaN(propertyId)) {
      return res.status(400).json({ error: "Identificador de imóvel inválido." });
    }

    try {
      const [rows] = await connection.query<PropertyAggregateRow[]>(
        `
          SELECT
            p.*,
            COALESCE(p.promo_percentage, p.promotion_percentage) AS promo_percentage_resolved,
            COALESCE(p.promo_start_date, DATE(p.promotion_start)) AS promo_start_date_resolved,
            COALESCE(p.promo_end_date, DATE(p.promotion_end)) AS promo_end_date_resolved,
            ANY_VALUE(a.id) AS agency_id,
            ANY_VALUE(a.name) AS agency_name,
            ANY_VALUE(a.logo_url) AS agency_logo_url,
            ANY_VALUE(a.address) AS agency_address,
            ANY_VALUE(a.city) AS agency_city,
            ANY_VALUE(a.state) AS agency_state,
            ANY_VALUE(a.phone) AS agency_phone,
            ANY_VALUE(COALESCE(u.name, u_owner.name)) AS broker_name,
            ANY_VALUE(COALESCE(u.phone, u_owner.phone)) AS broker_phone,
            ANY_VALUE(COALESCE(u.email, u_owner.email)) AS broker_email,
            GROUP_CONCAT(DISTINCT pi.image_url ORDER BY pi.id) AS images
          FROM properties p
          LEFT JOIN brokers b ON p.broker_id = b.id
          LEFT JOIN users u ON u.id = b.id
          LEFT JOIN users u_owner ON u_owner.id = p.owner_id
          LEFT JOIN agencies a ON b.agency_id = a.id
          LEFT JOIN property_images pi ON pi.property_id = p.id
          WHERE p.id = ?
          GROUP BY p.id
        `,
        [propertyId]
      );

      if (!rows || rows.length === 0) {
        return res.status(404).json({ error: "Imóvel não encontrado." });
      }

      const property = rows[0];
      const isOwner =
        (property.broker_id != null && property.broker_id === (req as AuthRequest).userId) ||
        (property.owner_id != null && property.owner_id === (req as AuthRequest).userId);
      const isAdmin = (req as AuthRequest).userRole === 'admin';
      const showOwnerInfo = isOwner || isAdmin;

      return res.status(200).json(mapProperty(property, showOwnerInfo));
    } catch (error) {
      console.error("Erro ao buscar imóvel:", error);
      return res.status(500).json({ error: "Ocorreu um erro inesperado no servidor." });
    }
  }

  async create(req: AuthRequestWithFiles, res: Response) {
    const brokerId = req.userId;

    if (!brokerId) {
      return res.status(401).json({ error: "Corretor não autenticado." });
    }

    const {
      title,
      description,
      type,
      purpose,
      is_promoted,
      promo_percentage,
      promo_start_date,
      promo_end_date,
      promotion_percentage,
      promotion_start,
      promotion_end,
      price,
      price_sale,
      price_rent,
      code,
      owner_name,
      owner_phone,
      address,
      quadra,
      lote,
      numero,
      sem_numero,
      bairro,
      complemento,
      tipo_lote,
      city,
      state,
      cep,
      bedrooms,
      bathrooms,
      area_construida,
      area_terreno,
      area,
      garage_spots,
      has_wifi,
      tem_piscina,
      tem_energia_solar,
      tem_automacao,
      tem_ar_condicionado,
      eh_mobiliada,
      valor_condominio,
      valor_iptu,
    } = req.body ?? {};
    const semNumeroFlag = parseBoolean(sem_numero);

    if (!title || !description || !type || !purpose || !address || !city || !state) {
      return res.status(400).json({ error: "Campos obrigatórios não informados." });
    }

    const normalizedType = normalizePropertyType(type);
    if (!normalizedType) {
      return res.status(400).json({ error: "Tipo de imóvel inválido." });
    }

    const normalizedPurpose = normalizePurpose(purpose);
    if (!normalizedPurpose) {
      return res.status(400).json({ error: "Finalidade do imóvel invalida." });
    }

    if (owner_phone && String(owner_phone).trim().length > 0) {
      const ownerPhoneDigits = String(owner_phone).replace(/\D/g, "");
      if (ownerPhoneDigits.length !== 11) {
        return res.status(400).json({
          error: "Telefone do proprietário inválido.",
        });
      }
    }
    const numeroDigits = String(numero ?? '').replace(/\D/g, '');
    if (semNumeroFlag !== 1 && String(numero ?? '').trim().length > 0 && numeroDigits.length === 0) {
      return res.status(400).json({ error: 'Número do endereço deve conter apenas dígitos.' });
    }
    const numeroNormalizado = semNumeroFlag === 1 ? null : stringOrNull(numeroDigits);

    let promotionFlag: 0 | 1 = 0;
    let promotionPercentage: number | null = null;
    let promotionStartDate: string | null = null;
    let promotionEndDate: string | null = null;
    let promotionStart: string | null = null;
    let promotionEnd: string | null = null;
    try {
      const promotionPercentageInput = promo_percentage ?? promotion_percentage;
      const promotionStartInput = promo_start_date ?? promotion_start;
      const promotionEndInput = promo_end_date ?? promotion_end;
      promotionFlag = parseBoolean(is_promoted);
      promotionPercentage = parsePromotionPercentage(promotionPercentageInput);
      promotionStartDate = parsePromotionDate(promotionStartInput);
      promotionEndDate = parsePromotionDate(promotionEndInput);
      promotionStart = parsePromotionDateTime(promotionStartInput);
      promotionEnd = parsePromotionDateTime(promotionEndInput);
      if (promotionFlag === 0) {
        promotionPercentage = null;
        promotionStartDate = null;
        promotionEndDate = null;
        promotionStart = null;
        promotionEnd = null;
      }
    } catch (parseError) {
      return res.status(400).json({ error: (parseError as Error).message });
    }

    let numericPrice: number;
    let numericPriceSale: number | null = null;
    let numericPriceRent: number | null = null;
    try {
      if (normalizedPurpose === "Venda") {
        numericPriceSale = parseOptionalPrice(price_sale) ?? parsePrice(price);
        numericPrice = numericPriceSale;
      } else if (normalizedPurpose === "Aluguel") {
        numericPriceRent = parseOptionalPrice(price_rent) ?? parsePrice(price);
        numericPrice = numericPriceRent;
      } else {
        numericPriceSale = parseOptionalPrice(price_sale);
        numericPriceRent = parseOptionalPrice(price_rent);
        if (numericPriceSale == null || numericPriceRent == null) {
          return res.status(400).json({
            error: "Informe os precos de venda e aluguel para esta finalidade.",
          });
        }
        numericPrice = numericPriceSale;
      }
    } catch (parseError) {
      return res.status(400).json({ error: (parseError as Error).message });
    }

    try {
      const [brokerRows] = await connection.query<RowDataPacket[]>(
        'SELECT status FROM brokers WHERE id = ?',
        [brokerId]
      );

      if (!brokerRows || brokerRows.length === 0) {
        return res.status(403).json({ error: "Conta de corretor não encontrada." });
      }

      const brokerStatus = String(brokerRows[0].status ?? '')
        .trim()
        .toLowerCase();

      if (brokerStatus !== 'approved') {
        return res
          .status(403)
          .json({ error: 'Apenas corretores aprovados podem criar imóveis.' });
      }

      const [duplicateRows] = await connection.query<RowDataPacket[]>(
        `
          SELECT id FROM properties
          WHERE address = ?
            AND COALESCE(quadra, '') = COALESCE(?, '')
            AND COALESCE(lote, '') = COALESCE(?, '')
            AND COALESCE(numero, '') = COALESCE(?, '')
            AND COALESCE(bairro, '') = COALESCE(?, '')
          LIMIT 1
        `,
        [address, quadra ?? null, lote ?? null, numeroNormalizado, bairro ?? null]
      );

      if (duplicateRows.length > 0) {
        return res
          .status(409)
          .json({ error: 'Imóvel já cadastrado no sistema.' });
      }

      const numericBedrooms = parseInteger(bedrooms);
      const numericBathrooms = parseInteger(bathrooms);
      const numericGarageSpots = parseInteger(garage_spots);
      const numericAreaConstruida = parseDecimal(area_construida ?? area);
      const numericAreaTerreno = parseDecimal(area_terreno);
      const numericValorCondominio = parseDecimal(valor_condominio);
      const numericValorIptu = parseDecimal(valor_iptu);

      const hasWifiFlag = parseBoolean(has_wifi);
      const temPiscinaFlag = parseBoolean(tem_piscina);
      const temEnergiaSolarFlag = parseBoolean(tem_energia_solar);
      const temAutomacaoFlag = parseBoolean(tem_automacao);
      const temArCondicionadoFlag = parseBoolean(tem_ar_condicionado);
      const ehMobiliadaFlag = parseBoolean(eh_mobiliada);

      const imageUrls: string[] = [];
      const files = req.files ?? {};

      const imageFiles = files.images ?? [];
      if (imageFiles.length < 1) {
        return res.status(400).json({ error: 'Envie pelo menos 1 imagem do imóvel.' });
      }
      if (imageFiles.length > MAX_IMAGES_PER_PROPERTY) {
        return res.status(400).json({
          error: `Limite maximo de ${MAX_IMAGES_PER_PROPERTY} imagens por imovel.`,
        });
      }
      for (const file of imageFiles) {
        const uploaded = await uploadToCloudinary(file, 'properties');
        imageUrls.push(uploaded.url);
      }

      let videoUrl: string | null = null;
      if (files.video && files.video[0]) {
        const uploadedVideo = await uploadToCloudinary(files.video[0], 'videos');
        videoUrl = uploadedVideo.url;
      }

      const [result] = await connection.query<ResultSetHeader>(
        `
          INSERT INTO properties (
            broker_id,
            owner_id,
            title,
            description,
            type,
            purpose,
            status,
            is_promoted,
            promotion_percentage,
            promotion_start,
            promotion_end,
            promo_percentage,
            promo_start_date,
            promo_end_date,
            price,
            price_sale,
            price_rent,
            code,
            owner_name,
            owner_phone,
            address,
            quadra,
            lote,
            numero,
            bairro,
            complemento,
            tipo_lote,
            city,
            state,
            cep,
            bedrooms,
            bathrooms,
            area_construida,
            area_terreno,
            garage_spots,
            has_wifi,
            tem_piscina,
            tem_energia_solar,
            tem_automacao,
            tem_ar_condicionado,
            eh_mobiliada,
            valor_condominio,
            valor_iptu,
            video_url
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `,
        [
          brokerId,
          null,
          title,
          description,
          normalizedType,
          normalizedPurpose,
          'pending_approval',
          promotionFlag,
          promotionPercentage,
          promotionStart,
          promotionEnd,
          promotionPercentage,
          promotionStartDate,
          promotionEndDate,
          numericPrice,
          numericPriceSale,
          numericPriceRent,
          stringOrNull(code),
          stringOrNull(owner_name),
          stringOrNull(owner_phone)?.replace(/\D/g, '') ?? null,
          address,
          stringOrNull(quadra),
          stringOrNull(lote),
          numeroNormalizado,
          stringOrNull(bairro),
          stringOrNull(complemento),
          stringOrNull(tipo_lote),
          city,
          state,
          stringOrNull(cep),
          numericBedrooms,
          numericBathrooms,
          numericAreaConstruida,
          numericAreaTerreno,
          numericGarageSpots,
          hasWifiFlag,
          temPiscinaFlag,
          temEnergiaSolarFlag,
          temAutomacaoFlag,
          temArCondicionadoFlag,
          ehMobiliadaFlag,
          numericValorCondominio,
          numericValorIptu,
          videoUrl,
        ]
      );

      const propertyId = result.insertId;

      if (imageUrls.length > 0) {
        const values = imageUrls.map((url) => [propertyId, url]);
        await connection.query(
          'INSERT INTO property_images (property_id, image_url) VALUES ?',
          [values]
        );
      }

      if (promotionFlag === 1) {
        try {
          await notifyPromotionStarted({
            propertyId,
            propertyTitle: title,
            promotionPercentage,
          });
        } catch (promotionNotifyError) {
          console.error('Erro ao notificar favoritos sobre promocao (create broker):', promotionNotifyError);
        }
      }

      try {
        await notifyAdmins(
          `Um novo imóvel '${title}' foi adicionado e aguarda aprovação.`,
          'property',
          propertyId
        );
      } catch (notifyError) {
        console.error('Erro ao enviar notificação aos administradores:', notifyError);
      }

      return res.status(201).json({
        message: 'Imóvel criado com sucesso!',
        propertyId,
        status: 'pending_approval',
        images: imageUrls,
        video: videoUrl,
      });
    } catch (error) {
      console.error('Erro ao criar imóvel:', error);
      const knownError = error as { statusCode?: number } | null;
      if (knownError?.statusCode === 413) {
        return res.status(413).json({
          error: 'Arquivo muito grande. Reduza o tamanho das imagens e tente novamente.',
        });
      }
      return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
  }

  async createForClient(req: AuthRequestWithFiles, res: Response) {
    const userId = req.userId;

    if (!userId) {
      return res.status(401).json({ error: 'Usuario nao autenticado.' });
    }

    const {
      title,
      description,
      type,
      purpose,
      is_promoted,
      promo_percentage,
      promo_start_date,
      promo_end_date,
      promotion_percentage,
      promotion_start,
      promotion_end,
      price,
      price_sale,
      price_rent,
      code,
      owner_name,
      owner_phone,
      address,
      quadra,
      lote,
      numero,
      sem_numero,
      bairro,
      complemento,
      tipo_lote,
      city,
      state,
      cep,
      bedrooms,
      bathrooms,
      area_construida,
      area_terreno,
      area,
      garage_spots,
      has_wifi,
      tem_piscina,
      tem_energia_solar,
      tem_automacao,
      tem_ar_condicionado,
      eh_mobiliada,
      valor_condominio,
      valor_iptu,
    } = req.body ?? {};
    const semNumeroFlag = parseBoolean(sem_numero);

    if (!title || !description || !type || !purpose || !address || !city || !state) {
      return res.status(400).json({ error: 'Campos obrigatórios não informados.' });
    }

    const normalizedType = normalizePropertyType(type);
    if (!normalizedType) {
      return res.status(400).json({ error: 'Tipo de imóvel inválido.' });
    }

    const normalizedPurpose = normalizePurpose(purpose);
    if (!normalizedPurpose) {
      return res.status(400).json({ error: 'Finalidade do imovel invalida.' });
    }

    if (owner_phone && String(owner_phone).trim().length > 0) {
      const ownerPhoneDigits = String(owner_phone).replace(/\D/g, '');
      if (ownerPhoneDigits.length !== 11) {
        return res.status(400).json({
          error: 'Telefone do proprietário inválido.',
        });
      }
    }
    const numeroDigits = String(numero ?? '').replace(/\D/g, '');
    if (semNumeroFlag !== 1 && String(numero ?? '').trim().length > 0 && numeroDigits.length === 0) {
      return res.status(400).json({ error: 'Número do endereço deve conter apenas dígitos.' });
    }
    const numeroNormalizado = semNumeroFlag === 1 ? null : stringOrNull(numeroDigits);

    let promotionFlag: 0 | 1 = 0;
    let promotionPercentage: number | null = null;
    let promotionStartDate: string | null = null;
    let promotionEndDate: string | null = null;
    let promotionStart: string | null = null;
    let promotionEnd: string | null = null;
    try {
      const promotionPercentageInput = promo_percentage ?? promotion_percentage;
      const promotionStartInput = promo_start_date ?? promotion_start;
      const promotionEndInput = promo_end_date ?? promotion_end;
      promotionFlag = parseBoolean(is_promoted);
      promotionPercentage = parsePromotionPercentage(promotionPercentageInput);
      promotionStartDate = parsePromotionDate(promotionStartInput);
      promotionEndDate = parsePromotionDate(promotionEndInput);
      promotionStart = parsePromotionDateTime(promotionStartInput);
      promotionEnd = parsePromotionDateTime(promotionEndInput);
      if (promotionFlag === 0) {
        promotionPercentage = null;
        promotionStartDate = null;
        promotionEndDate = null;
        promotionStart = null;
        promotionEnd = null;
      }
    } catch (parseError) {
      return res.status(400).json({ error: (parseError as Error).message });
    }

    let numericPrice: number;
    let numericPriceSale: number | null = null;
    let numericPriceRent: number | null = null;
    try {
      if (normalizedPurpose === 'Venda') {
        numericPriceSale = parseOptionalPrice(price_sale) ?? parsePrice(price);
        numericPrice = numericPriceSale;
      } else if (normalizedPurpose === 'Aluguel') {
        numericPriceRent = parseOptionalPrice(price_rent) ?? parsePrice(price);
        numericPrice = numericPriceRent;
      } else {
        numericPriceSale = parseOptionalPrice(price_sale);
        numericPriceRent = parseOptionalPrice(price_rent);
        if (numericPriceSale == null || numericPriceRent == null) {
          return res.status(400).json({
            error: 'Informe os precos de venda e aluguel para esta finalidade.',
          });
        }
        numericPrice = numericPriceSale;
      }
    } catch (parseError) {
      return res.status(400).json({ error: (parseError as Error).message });
    }

    try {
      const [duplicateRows] = await connection.query<RowDataPacket[]>(
        `
          SELECT id FROM properties
          WHERE address = ?
            AND COALESCE(quadra, '') = COALESCE(?, '')
            AND COALESCE(lote, '') = COALESCE(?, '')
            AND COALESCE(numero, '') = COALESCE(?, '')
            AND COALESCE(bairro, '') = COALESCE(?, '')
          LIMIT 1
        `,
        [address, quadra ?? null, lote ?? null, numeroNormalizado, bairro ?? null]
      );

      if (duplicateRows.length > 0) {
        return res
          .status(409)
          .json({ error: 'Imovel ja cadastrado no sistema.' });
      }

      const numericBedrooms = parseInteger(bedrooms);
      const numericBathrooms = parseInteger(bathrooms);
      const numericGarageSpots = parseInteger(garage_spots);
      const numericAreaConstruida = parseDecimal(area_construida ?? area);
      const numericAreaTerreno = parseDecimal(area_terreno);
      const numericValorCondominio = parseDecimal(valor_condominio);
      const numericValorIptu = parseDecimal(valor_iptu);

      const hasWifiFlag = parseBoolean(has_wifi);
      const temPiscinaFlag = parseBoolean(tem_piscina);
      const temEnergiaSolarFlag = parseBoolean(tem_energia_solar);
      const temAutomacaoFlag = parseBoolean(tem_automacao);
      const temArCondicionadoFlag = parseBoolean(tem_ar_condicionado);
      const ehMobiliadaFlag = parseBoolean(eh_mobiliada);

      const imageUrls: string[] = [];
      const files = req.files ?? {};

      const imageFiles = files.images ?? [];
      if (imageFiles.length < 1) {
        return res.status(400).json({ error: 'Envie pelo menos 1 imagem do imovel.' });
      }
      if (imageFiles.length > MAX_IMAGES_PER_PROPERTY) {
        return res.status(400).json({
          error: `Limite maximo de ${MAX_IMAGES_PER_PROPERTY} imagens por imovel.`,
        });
      }
      for (const file of imageFiles) {
        const uploaded = await uploadToCloudinary(file, 'properties');
        imageUrls.push(uploaded.url);
      }

      let videoUrl: string | null = null;
      if (files.video && files.video[0]) {
        const uploadedVideo = await uploadToCloudinary(files.video[0], 'videos');
        videoUrl = uploadedVideo.url;
      }

      const [result] = await connection.query<ResultSetHeader>(
        `
          INSERT INTO properties (
            broker_id,
            owner_id,
            title,
            description,
            type,
            purpose,
            status,
            is_promoted,
            promotion_percentage,
            promotion_start,
            promotion_end,
            promo_percentage,
            promo_start_date,
            promo_end_date,
            price,
            price_sale,
            price_rent,
            code,
            owner_name,
            owner_phone,
            address,
            quadra,
            lote,
            numero,
            bairro,
            complemento,
            tipo_lote,
            city,
            state,
            cep,
            bedrooms,
            bathrooms,
            area_construida,
            area_terreno,
            garage_spots,
            has_wifi,
            tem_piscina,
            tem_energia_solar,
            tem_automacao,
            tem_ar_condicionado,
            eh_mobiliada,
            valor_condominio,
            valor_iptu,
            video_url
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `,
        [
          null,
          userId,
          title,
          description,
          normalizedType,
          normalizedPurpose,
          'pending_approval',
          promotionFlag,
          promotionPercentage,
          promotionStart,
          promotionEnd,
          promotionPercentage,
          promotionStartDate,
          promotionEndDate,
          numericPrice,
          numericPriceSale,
          numericPriceRent,
          stringOrNull(code),
          stringOrNull(owner_name),
          stringOrNull(owner_phone)?.replace(/\D/g, '') ?? null,
          address,
          stringOrNull(quadra),
          stringOrNull(lote),
          numeroNormalizado,
          stringOrNull(bairro),
          stringOrNull(complemento),
          stringOrNull(tipo_lote),
          city,
          state,
          stringOrNull(cep),
          numericBedrooms,
          numericBathrooms,
          numericAreaConstruida,
          numericAreaTerreno,
          numericGarageSpots,
          hasWifiFlag,
          temPiscinaFlag,
          temEnergiaSolarFlag,
          temAutomacaoFlag,
          temArCondicionadoFlag,
          ehMobiliadaFlag,
          numericValorCondominio,
          numericValorIptu,
          videoUrl,
        ]
      );

      const propertyId = result.insertId;

      if (imageUrls.length > 0) {
        const values = imageUrls.map((url) => [propertyId, url]);
        await connection.query(
          'INSERT INTO property_images (property_id, image_url) VALUES ?',
          [values]
        );
      }

      if (promotionFlag === 1) {
        try {
          await notifyPromotionStarted({
            propertyId,
            propertyTitle: title,
            promotionPercentage,
          });
        } catch (promotionNotifyError) {
          console.error('Erro ao notificar favoritos sobre promocao (create client):', promotionNotifyError);
        }
      }

      try {
        await notifyAdmins(
          `Novo imovel enviado por cliente: '${title}'.`,
          'property',
          propertyId
        );
      } catch (notifyError) {
        console.error('Erro ao notificar admins sobre imovel de cliente:', notifyError);
      }

      return res.status(201).json({
        message: 'Imovel criado com sucesso!',
        propertyId,
        status: 'pending_approval',
        images: imageUrls,
        video: videoUrl,
      });
    } catch (error) {
      console.error('Erro ao criar imovel (cliente):', error);
      const knownError = error as { statusCode?: number } | null;
      if (knownError?.statusCode === 413) {
        return res.status(413).json({
          error: 'Arquivo muito grande. Reduza o tamanho das imagens e tente novamente.',
        });
      }
      return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
  }

  async update(req: AuthRequest, res: Response) {
    const propertyId = Number(req.params.id);
    const userId = req.userId;

    if (!userId) {
      return res.status(401).json({ error: 'Usuario nao autenticado.' });
    }

    if (Number.isNaN(propertyId)) {
      return res.status(400).json({ error: 'Identificador de imóvel invalido.' });
    }

    try {
      const [propertyRows] = await connection.query<PropertyRow[]>(
        'SELECT * FROM properties WHERE id = ?',
        [propertyId]
      );

      if (!propertyRows || propertyRows.length === 0) {
        return res.status(404).json({ error: 'Imóvel nao encontrado.' });
      }

      const property = propertyRows[0];
      const brokerId = property.broker_id != null ? Number(property.broker_id) : null;

      const isOwner =
        (property.broker_id != null && property.broker_id === userId) ||
        (property.owner_id != null && property.owner_id === userId);
      if (!isOwner) {
        return res.status(403).json({ error: 'Acesso nao autorizado a este imovel.' });
      }

      const previousSalePrice =
        property.price_sale != null ? Number(property.price_sale) : Number(property.price);
      const previousRentPrice =
        property.price_rent != null ? Number(property.price_rent) : Number(property.price);
      const previousPromotionFlag = toBoolean(property.is_promoted);

      const body = req.body ?? {};
      const bodyKeys = Object.keys(body);
      const semNumeroBody =
        body.sem_numero !== undefined ? parseBoolean(body.sem_numero) : null;

      const nextPurpose = normalizePurpose(body.purpose) ?? property.purpose;
      const purposeLower = String(nextPurpose ?? '').toLowerCase();
      const supportsSale = purposeLower.includes('vend');
      const supportsRent = purposeLower.includes('alug');
      let nextSalePrice = previousSalePrice;
      let nextRentPrice = previousRentPrice;
      let saleTouched = false;
      let rentTouched = false;
      let nextPromotionFlag = previousPromotionFlag ? 1 : 0;
      let nextPromotionPercentage =
        property.promo_percentage != null
          ? Number(property.promo_percentage)
          : property.promotion_percentage != null
            ? Number(property.promotion_percentage)
            : null;

      // Always allow editing all fields, even if approved
      const updatableFields = new Set([
        'title',
        'description',
        'type',
        'purpose',
        'status',
        'price',
        'price_sale',
        'price_rent',
        'is_promoted',
        'promo_percentage',
        'promo_start_date',
        'promo_end_date',
        'promotion_percentage',
        'promotion_start',
        'promotion_end',
        'code',
        'owner_name',
        'owner_phone',
        'address',
        'quadra',
        'lote',
        'numero',
        'sem_numero',
        'bairro',
        'complemento',
        'tipo_lote',
        'city',
        'state',
        'cep',
        'bedrooms',
        'bathrooms',
        'area_construida',
        'area_terreno',
        'garage_spots',
        'has_wifi',
        'tem_piscina',
        'tem_energia_solar',
        'tem_automacao',
        'tem_ar_condicionado',
        'eh_mobiliada',
        'valor_condominio',
        'valor_iptu',
        'video_url',
      ]);

      const fields: string[] = [];
      const values: any[] = [];
      let nextStatus: Nullable<PropertyStatus> = null;

      for (const key of bodyKeys) {
        if (!updatableFields.has(key)) {
          continue;
        }

        switch (key) {
          case 'status': {
            const normalized = normalizeStatus(body.status);
            if (!normalized) {
              return res.status(400).json({ error: 'Status informado invalido.' });
            }
            nextStatus = normalized;
            fields.push('status = ?');
            values.push(normalized);
            break;
          }
          case 'purpose': {
            const normalized = normalizePurpose(body.purpose);
            if (!normalized) {
              return res.status(400).json({ error: 'Finalidade informada e invalida.' });
            }
            fields.push('purpose = ?');
            values.push(normalized);
            break;
          }
          case 'type': {
            const normalized = normalizePropertyType(body.type);
            if (!normalized) {
              return res.status(400).json({ error: 'Tipo de imóvel inválido.' });
            }
            fields.push('type = ?');
            values.push(normalized);
            break;
          }
          case 'price': {
            try {
              const parsed = parsePrice(body.price);
              fields.push('price = ?');
              values.push(parsed);
              if (supportsSale && !supportsRent) {
                nextSalePrice = parsed;
                saleTouched = true;
              } else if (supportsRent && !supportsSale) {
                nextRentPrice = parsed;
                rentTouched = true;
              } else if (supportsSale && supportsRent) {
                nextSalePrice = parsed;
                saleTouched = true;
              }
            } catch (parseError) {
              return res.status(400).json({ error: (parseError as Error).message });
            }
            break;
          }
          case 'price_sale':
          case 'price_rent': {
            try {
              const parsed = parsePrice(body[key]);
              fields.push(`\`${key}\` = ?`);
              values.push(parsed);
              if (key === 'price_sale') {
                nextSalePrice = parsed;
                saleTouched = true;
              } else {
                nextRentPrice = parsed;
                rentTouched = true;
              }
            } catch (parseError) {
              return res.status(400).json({ error: (parseError as Error).message });
            }
            break;
          }
          case 'bedrooms':
          case 'bathrooms':
          case 'garage_spots': {
            try {
              fields.push(`\`${key}\` = ?`);
              values.push(parseInteger(body[key]));
            } catch (parseError) {
              return res.status(400).json({ error: (parseError as Error).message });
            }
            break;
          }
          case 'area_construida':
          case 'area_terreno':
          case 'valor_condominio':
          case 'valor_iptu': {
            try {
              fields.push(`\`${key}\` = ?`);
              values.push(parseDecimal(body[key]));
            } catch (parseError) {
              return res.status(400).json({ error: (parseError as Error).message });
            }
            break;
          }
          case 'has_wifi':
          case 'tem_piscina':
          case 'tem_energia_solar':
          case 'tem_automacao':
          case 'tem_ar_condicionado':
          case 'eh_mobiliada': {
            fields.push(`\`${key}\` = ?`);
            values.push(parseBoolean(body[key]));
            break;
          }
          case 'is_promoted': {
            const parsed = parseBoolean(body[key]);
            nextPromotionFlag = parsed;
            if (parsed === 0) {
              nextPromotionPercentage = null;
              fields.push('promo_percentage = ?');
              values.push(null);
              fields.push('promo_start_date = ?');
              values.push(null);
              fields.push('promo_end_date = ?');
              values.push(null);
              fields.push('promotion_percentage = ?');
              values.push(null);
              fields.push('promotion_start = ?');
              values.push(null);
              fields.push('promotion_end = ?');
              values.push(null);
            }
            fields.push('is_promoted = ?');
            values.push(parsed);
            break;
          }
          case 'promo_percentage':
          case 'promotion_percentage': {
            try {
              const parsed = parsePromotionPercentage(body[key]);
              nextPromotionPercentage = parsed;
              fields.push('promo_percentage = ?');
              values.push(parsed);
              fields.push('promotion_percentage = ?');
              values.push(parsed);
            } catch (parseError) {
              return res.status(400).json({ error: (parseError as Error).message });
            }
            break;
          }
          case 'promo_start_date':
          case 'promotion_start':
          case 'promo_end_date':
          case 'promotion_end': {
            try {
              const parsedDate = parsePromotionDate(body[key]);
              const parsedDateTime = parsePromotionDateTime(body[key]);
              if (key === 'promotion_start' || key === 'promo_start_date') {
                fields.push('promo_start_date = ?');
                values.push(parsedDate);
                fields.push('promotion_start = ?');
                values.push(parsedDateTime);
              } else {
                fields.push('promo_end_date = ?');
                values.push(parsedDate);
                fields.push('promotion_end = ?');
                values.push(parsedDateTime);
              }
            } catch (parseError) {
              return res.status(400).json({ error: (parseError as Error).message });
            }
            break;
          }
          case 'owner_phone': {
            const text = String(body[key] ?? '').trim();
            if (text.length > 0) {
              const digits = text.replace(/\D/g, '');
              if (digits.length !== 11) {
                return res.status(400).json({ error: 'Telefone do proprietário inválido.' });
              }
              fields.push('owner_phone = ?');
              values.push(digits);
            } else {
              fields.push('owner_phone = ?');
              values.push(null);
            }
            break;
          }
          case 'sem_numero': {
            // `sem_numero` e uma flag de entrada; persistimos apenas `numero`.
            break;
          }
          case 'numero': {
            if (semNumeroBody === 1) {
              fields.push('numero = ?');
              values.push(null);
              break;
            }
            const rawNumero = String(body.numero ?? '').trim();
            const numeroDigits = rawNumero.replace(/\D/g, '');
            if (rawNumero.length > 0 && numeroDigits.length === 0) {
              return res.status(400).json({ error: 'Número do endereço deve conter apenas dígitos.' });
            }
            fields.push('numero = ?');
            values.push(stringOrNull(numeroDigits));
            break;
          }
          default: {
            fields.push(`\`${key}\` = ?`);
            values.push(stringOrNull(body[key]));
          }
        }
      }

      if (semNumeroBody === 1 && !bodyKeys.includes('numero')) {
        fields.push('numero = ?');
        values.push(null);
      }

      if (fields.length === 0) {
        return res.status(400).json({ error: 'Nenhum dado fornecido para atualizacao.' });
      }

      values.push(propertyId);

      await connection.query(
        `UPDATE properties SET ${fields.join(', ')} WHERE id = ?`,
        values
      );

      if (Array.isArray(body.images) && property.status !== 'approved') {
        const images: string[] = body.images
          .filter((url: unknown) => typeof url === 'string' && url.trim().length > 0)
          .map((url: string) => url.trim());

        await connection.query('DELETE FROM property_images WHERE property_id = ?', [propertyId]);

        if (images.length > 0) {
          const imageValues = images.map((url) => [propertyId, url]);
          await connection.query(
            'INSERT INTO property_images (property_id, image_url) VALUES ?',
            [imageValues]
          );
        }
      }

      const effectiveStatus = nextStatus ?? property.status;
      if (effectiveStatus === 'approved' && (saleTouched || rentTouched)) {
        try {
          await notifyPriceDropIfNeeded({
            propertyId,
            propertyTitle: property.title,
            previousSalePrice,
            newSalePrice: saleTouched ? nextSalePrice : undefined,
            previousRentPrice,
            newRentPrice: rentTouched ? nextRentPrice : undefined,
          });
        } catch (notifyError) {
          console.error('Erro ao notificar queda de preco:', notifyError);
        }
      }

      if (!previousPromotionFlag && nextPromotionFlag === 1) {
        try {
          await notifyPromotionStarted({
            propertyId,
            propertyTitle: property.title,
            promotionPercentage: nextPromotionPercentage,
          });
        } catch (notifyError) {
          console.error('Erro ao notificar promoção de imóvel:', notifyError);
        }
      }

      if (nextStatus && NOTIFY_ON_STATUS.has(nextStatus)) {
        if (brokerId == null) {
          return res.status(403).json({ error: 'Apenas corretores podem fechar negocio.' });
        }
        try {
          const action = nextStatus === 'sold' ? 'vendido' : 'alugado';
          await notifyAdmins(
            `O imóvel '${property.title}' foi marcado como ${action}.`,
            'property',
            propertyId
          );
        } catch (notifyError) {
          console.error('Erro ao registrar notificacao:', notifyError);
        }

        const dealType = resolveDealTypeFromStatus(nextStatus);
        if (dealType) {
          let dealAmount: number;
          try {
            const fallbackPrice =
              dealType === 'sale'
                ? Number(property.price_sale ?? property.price)
                : Number(property.price_rent ?? property.price);
            dealAmount = resolveDealAmount(
              body.amount ?? body.sale_price ?? body.price,
              fallbackPrice
            );
          } catch (parseError) {
            return res.status(400).json({ error: (parseError as Error).message });
          }

          let commissionRate: number;
          try {
            commissionRate =
              parseDecimal(body.commission_rate) ??
              (property.commission_rate != null ? Number(property.commission_rate) : 5.0);
          } catch (parseError) {
            return res.status(400).json({ error: (parseError as Error).message });
          }

          let commissionCycles = 0;
          try {
            const parsedCycles = parseInteger(body.commission_cycles);
            if (parsedCycles != null) {
              if (parsedCycles < 0) {
                return res.status(400).json({ error: 'Comissões ja realizadas invalidas.' });
              }
              commissionCycles = parsedCycles;
            }
          } catch (parseError) {
            return res.status(400).json({ error: (parseError as Error).message });
          }

          const normalizedInterval = normalizeRecurrenceInterval(body.recurrence_interval);
          if (
            body.recurrence_interval !== undefined &&
            body.recurrence_interval !== null &&
            normalizedInterval == null
          ) {
            return res.status(400).json({ error: 'Intervalo de recorrencia invalido.' });
          }
          const recurrenceInterval = normalizedInterval ?? 'none';

          const commissionAmount = calculateCommissionAmount(dealAmount, commissionRate);
          const iptuValue = property.valor_iptu != null ? Number(property.valor_iptu) : null;
          const condominioValue =
            property.valor_condominio != null ? Number(property.valor_condominio) : null;
          const isRecurring = recurrenceInterval !== 'none' ? 1 : 0;

          await upsertSaleRecord(connection, {
            propertyId,
            brokerId,
            dealType,
            salePrice: dealAmount,
            commissionRate,
            commissionAmount,
            iptuValue,
            condominioValue,
            isRecurring,
            commissionCycles,
            recurrenceInterval,
          });

          await connection.query(
            'UPDATE properties SET sale_value = ?, commission_rate = ?, commission_value = ? WHERE id = ?',
            [dealAmount, commissionRate, commissionAmount, propertyId]
          );
        }
      }

      return res.status(200).json({ message: 'Imóvel atualizado com sucesso!' });
    } catch (error) {
      console.error('Erro ao atualizar imóvel:', error);
      return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
  }

  async updateStatus(req: AuthRequest, res: Response) {
    const { status } = req.body as { status?: string };
    const normalized = normalizeStatus(status);

    if (!normalized) {
      return res.status(400).json({ error: 'Status informado é inválido.' });
    }

    req.body = { status: normalized } as any;
    return this.update(req, res);
  }

  async closeDeal(req: AuthRequest, res: Response) {
    const propertyId = Number(req.params.id);
    const brokerId = req.userId;

    if (!brokerId) {
      return res.status(401).json({ error: 'Corretor não autenticado.' });
    }

    if (Number.isNaN(propertyId)) {
      return res.status(400).json({ error: 'Identificador de imóvel inválido.' });
    }

    const { type, amount, commission_rate, commission_cycles, recurrence_interval } = req.body as {
      type?: string;
      amount?: number | string;
      commission_rate?: number | string;
      commission_cycles?: number | string;
      recurrence_interval?: string;
    };

    const dealType = normalizeDealType(type);
    if (!dealType) {
      return res.status(400).json({ error: 'Tipo de negocio invalido.' });
    }

    try {
      const [propertyRows] = await connection.query<PropertyRow[]>(
        'SELECT * FROM properties WHERE id = ?',
        [propertyId]
      );

      if (!propertyRows || propertyRows.length === 0) {
        return res.status(404).json({ error: 'Imóvel não encontrado.' });
      }

      const property = propertyRows[0];
      if (property.broker_id !== brokerId) {
        return res.status(403).json({ error: 'Acesso não autorizado a este imóvel.' });
      }

      if (property.status === 'pending_approval' || property.status === 'rejected') {
        return res.status(403).json({ error: 'Imóvel ainda não pode ser fechado.' });
      }



      if (!purposeAllowsDeal(property.purpose, dealType)) {
        return res.status(400).json({ error: 'Tipo de negocio nao permitido para esta finalidade.' });
      }

      const fallbackPrice =
        dealType === 'sale'
          ? Number(property.price_sale ?? property.price)
          : Number(property.price_rent ?? property.price);
      let dealAmount: number;
      try {
        dealAmount = resolveDealAmount(amount, fallbackPrice);
      } catch (parseError) {
        return res.status(400).json({ error: (parseError as Error).message });
      }

      let commissionRate: number;
      try {
        commissionRate =
          parseDecimal(commission_rate) ??
          (property.commission_rate != null ? Number(property.commission_rate) : 5.0);
      } catch (parseError) {
        return res.status(400).json({ error: (parseError as Error).message });
      }

      let commissionCycles = 0;
      try {
        const parsedCycles = parseInteger(commission_cycles);
        if (parsedCycles != null) {
          if (parsedCycles < 0) {
            return res.status(400).json({ error: "Comissões já realizadas inválidas." });
          }
          commissionCycles = parsedCycles;
        }
      } catch (parseError) {
        return res.status(400).json({ error: (parseError as Error).message });
      }

      const normalizedInterval = normalizeRecurrenceInterval(recurrence_interval);
      if (
        recurrence_interval !== undefined &&
        recurrence_interval !== null &&
        normalizedInterval == null
      ) {
        return res.status(400).json({ error: "Intervalo de recorrencia invalido." });
      }
      const recurrenceInterval = normalizedInterval ?? "none";

      const commissionAmount = calculateCommissionAmount(dealAmount, commissionRate);
      const iptuValue = property.valor_iptu != null ? Number(property.valor_iptu) : null;
      const condominioValue =
        property.valor_condominio != null ? Number(property.valor_condominio) : null;
      const newStatus: PropertyStatus = dealType === 'sale' ? 'sold' : 'rented';
      const isRecurring = recurrenceInterval !== "none" ? 1 : 0;

      const db = await connection.getConnection();
      try {
        await db.beginTransaction();
        await db.query(
          'UPDATE properties SET status = ?, sale_value = ?, commission_rate = ?, commission_value = ? WHERE id = ?',
          [newStatus, dealAmount, commissionRate, commissionAmount, propertyId]
        );

        await upsertSaleRecord(db, {
          propertyId,
          brokerId,
          dealType,
          salePrice: dealAmount,
          commissionRate,
          commissionAmount,
          iptuValue,
          condominioValue,
          isRecurring,
          commissionCycles,
          recurrenceInterval,
        });

        await db.commit();
      } catch (error) {
        await db.rollback();
        throw error;
      } finally {
        db.release();
      }

      return res.status(200).json({
        message: 'Negócio fechado com sucesso.',
        status: newStatus,
        sale: {
          property_id: propertyId,
          deal_type: dealType,
          sale_price: dealAmount,
          commission_rate: commissionRate,
          commission_amount: commissionAmount,
          iptu_value: iptuValue,
          condominio_value: condominioValue,
          is_recurring: isRecurring,
          commission_cycles: commissionCycles,
          recurrence_interval: recurrenceInterval,
        },
      });
    } catch (error) {
      console.error('Erro ao fechar negocio:', error);
      return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
  }

  async cancelDeal(req: AuthRequest, res: Response) {
    const propertyId = Number(req.params.id);
    const brokerId = req.userId;

    if (!brokerId) {
      return res.status(401).json({ error: 'Corretor nao autenticado.' });
    }

    if (Number.isNaN(propertyId)) {
      return res.status(400).json({ error: 'Identificador de imóvel invalido.' });
    }

    try {
      const [propertyRows] = await connection.query<PropertyRow[]>(
        'SELECT id, broker_id, status FROM properties WHERE id = ?',
        [propertyId]
      );

      if (!propertyRows || propertyRows.length === 0) {
        return res.status(404).json({ error: 'Imóvel nao encontrado.' });
      }

      const property = propertyRows[0];
      if (property.broker_id !== brokerId) {
        return res.status(403).json({ error: 'Acesso nao autorizado a este imóvel.' });
      }

      if (property.status !== 'sold' && property.status !== 'rented') {
        return res.status(400).json({ error: 'Este imóvel nao possui negocio fechado.' });
      }

      const db = await connection.getConnection();
      try {
        await db.beginTransaction();
        await db.query(
          'UPDATE properties SET status = ?, sale_value = NULL, commission_rate = NULL, commission_value = NULL WHERE id = ?',
          ['approved', propertyId]
        );
        await db.query('DELETE FROM sales WHERE property_id = ?', [propertyId]);
        await db.commit();
      } catch (error) {
        await db.rollback();
        throw error;
      } finally {
        db.release();
      }

      return res.status(200).json({
        message: 'Negocio cancelado com sucesso.',
        status: 'approved',
      });
    } catch (error) {
      console.error('Erro ao cancelar negocio:', error);
      return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
  }

  async delete(req: AuthRequest, res: Response) {
    const propertyId = Number(req.params.id);
    const userId = req.userId;

    if (!userId) {
      return res.status(401).json({ error: 'Usuario nao autenticado.' });
    }

    if (Number.isNaN(propertyId)) {
      return res.status(400).json({ error: 'Identificador de imóvel inválido.' });
    }

    try {
      const [propertyRows] = await connection.query<RowDataPacket[]>(
        'SELECT broker_id, owner_id FROM properties WHERE id = ?',
        [propertyId]
      );

      if (!propertyRows || propertyRows.length === 0) {
        return res.status(404).json({ error: 'Imóvel não encontrado.' });
      }

      const property = propertyRows[0];
      const isOwner =
        (property.broker_id != null && property.broker_id === userId) ||
        (property.owner_id != null && property.owner_id === userId);
      if (!isOwner) {
        return res.status(403).json({ error: 'Voce nao tem permissao para deletar este imovel.' });
      }

      await connection.query('DELETE FROM properties WHERE id = ?', [propertyId]);

      return res.status(200).json({ message: 'Imóvel deletado com sucesso!' });
    } catch (error) {
      console.error('Erro ao deletar imóvel:', error);
      return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
    }
  }

  async getAvailableCities(req: Request, res: Response) {
    try {
      const [rows] = await connection.query<RowDataPacket[]>(
        `
          SELECT DISTINCT city
          FROM properties
          WHERE city IS NOT NULL
            AND city <> ''
            AND status = 'approved'
            AND COALESCE(visibility, 'PUBLIC') = 'PUBLIC'
          ORDER BY city ASC
        `
      );
      return res.status(200).json(rows.map((row) => row.city));
    } catch (error) {
      console.error('Erro ao buscar cidades disponíveis:', error);
      return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
    }
  }

  async listUserProperties(req: AuthRequest, res: Response) {
    const userId = req.userId;

    if (!userId) {
      return res.status(401).json({ error: 'Usuário não autenticado.' });
    }

    try {
      const [rows] = await connection.query<PropertyAggregateRow[]>(
        `
          SELECT
            p.*,
            COALESCE(p.promo_percentage, p.promotion_percentage) AS promo_percentage_resolved,
            COALESCE(p.promo_start_date, DATE(p.promotion_start)) AS promo_start_date_resolved,
            COALESCE(p.promo_end_date, DATE(p.promotion_end)) AS promo_end_date_resolved,
            ANY_VALUE(a.id) AS agency_id,
            ANY_VALUE(a.name) AS agency_name,
            ANY_VALUE(a.logo_url) AS agency_logo_url,
            ANY_VALUE(a.address) AS agency_address,
            ANY_VALUE(a.city) AS agency_city,
            ANY_VALUE(a.state) AS agency_state,
            ANY_VALUE(a.phone) AS agency_phone,
            ANY_VALUE(COALESCE(u.name, u_owner.name)) AS broker_name,
            ANY_VALUE(COALESCE(u.phone, u_owner.phone)) AS broker_phone,
            ANY_VALUE(COALESCE(u.email, u_owner.email)) AS broker_email,
            GROUP_CONCAT(DISTINCT pi.image_url ORDER BY pi.id) AS images
          FROM properties p
          LEFT JOIN brokers b ON p.broker_id = b.id
          LEFT JOIN users u ON u.id = b.id
          LEFT JOIN users u_owner ON u_owner.id = p.owner_id
          LEFT JOIN agencies a ON b.agency_id = a.id
          LEFT JOIN property_images pi ON pi.property_id = p.id
          WHERE p.owner_id = ? OR p.broker_id = ?
          GROUP BY p.id
          ORDER BY p.created_at DESC
        `,
        [userId, userId]
      );

      return res.json(rows.map(row => mapProperty(row, true)));
    } catch (error) {
      console.error('Erro ao listar imóveis do usuário:', error);
      return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
  }

  async listPublicProperties(req: Request, res: Response) {
    const {
      page = '1',
      limit = '20',
      type,
      purpose,
      city,
      bairro,
      minPrice,
      maxPrice,
      bedrooms,
      bathrooms,
      tipo_lote,
      has_wifi,
      tem_piscina,
      tem_energia_solar,
      tem_automacao,
      tem_ar_condicionado,
      eh_mobiliada,
      sortBy,
      order,
      searchTerm,
      status,
    } = req.query;

    const numericLimit = Math.min(Math.max(Number(limit) || 20, 1), 100);
    const numericPage = Math.max(Number(page) || 1, 1);
    const offset = (numericPage - 1) * numericLimit;

    const whereClauses: string[] = [];
    const params: any[] = [];

    const effectiveStatus: PropertyStatus = 'approved';
    whereClauses.push('p.status = ?');
    params.push(effectiveStatus);
    whereClauses.push(`COALESCE(p.visibility, 'PUBLIC') = 'PUBLIC'`);

    if (type) {
      const normalizedType = normalizePropertyType(type);
      if (!normalizedType) {
        return res.status(400).json({ error: 'Tipo de imóvel inválido.' });
      }
      whereClauses.push('p.type = ?');
      params.push(normalizedType);
    }

    const normalizedPurpose = normalizePurpose(purpose);
    let priceColumn = 'p.price';
    if (normalizedPurpose) {
      if (normalizedPurpose === 'Venda') {
        whereClauses.push('(p.purpose = ? OR p.purpose = ?)');
        params.push('Venda', 'Venda e Aluguel');
        priceColumn = 'COALESCE(p.price_sale, p.price)';
      } else if (normalizedPurpose === 'Aluguel') {
        whereClauses.push('(p.purpose = ? OR p.purpose = ?)');
        params.push('Aluguel', 'Venda e Aluguel');
        priceColumn = 'COALESCE(p.price_rent, p.price)';
      } else {
        whereClauses.push('p.purpose = ?');
        params.push('Venda e Aluguel');
        priceColumn = 'COALESCE(p.price_sale, p.price)';
      }
    }

    if (city) {
      whereClauses.push('p.city LIKE ?');
      params.push(`%${city}%`);
    }

    if (bairro) {
      whereClauses.push('p.bairro LIKE ?');
      params.push(`%${bairro}%`);
    }

    if (minPrice) {
      const value = Number(minPrice);
      if (!Number.isNaN(value)) {
        whereClauses.push(`${priceColumn} >= ?`);
        params.push(value);
      }
    }

    if (maxPrice) {
      const value = Number(maxPrice);
      if (!Number.isNaN(value)) {
        whereClauses.push(`${priceColumn} <= ?`);
        params.push(value);
      }
    }

    if (bedrooms) {
      const value = Number(bedrooms);
      if (!Number.isNaN(value) && value > 0) {
        const normalized = Math.trunc(value);
        if (normalized >= 4) {
          whereClauses.push('p.bedrooms >= ?');
          params.push(4);
        } else {
          whereClauses.push('p.bedrooms = ?');
          params.push(normalized);
        }
      }
    }

    if (bathrooms) {
      const value = Number(bathrooms);
      if (!Number.isNaN(value) && value > 0) {
        const normalized = Math.trunc(value);
        if (normalized >= 4) {
          whereClauses.push('p.bathrooms >= ?');
          params.push(4);
        } else {
          whereClauses.push('p.bathrooms = ?');
          params.push(normalized);
        }
      }
    }

    if (tipo_lote) {
      whereClauses.push('p.tipo_lote = ?');
      params.push(tipo_lote);
    }

    if (has_wifi !== undefined) {
      whereClauses.push('p.has_wifi = ?');
      params.push(parseBoolean(has_wifi));
    }

    if (tem_piscina !== undefined) {
      whereClauses.push('p.tem_piscina = ?');
      params.push(parseBoolean(tem_piscina));
    }

    if (tem_energia_solar !== undefined) {
      whereClauses.push('p.tem_energia_solar = ?');
      params.push(parseBoolean(tem_energia_solar));
    }

    if (tem_automacao !== undefined) {
      whereClauses.push('p.tem_automacao = ?');
      params.push(parseBoolean(tem_automacao));
    }

    if (tem_ar_condicionado !== undefined) {
      whereClauses.push('p.tem_ar_condicionado = ?');
      params.push(parseBoolean(tem_ar_condicionado));
    }

    if (eh_mobiliada !== undefined) {
      whereClauses.push('p.eh_mobiliada = ?');
      params.push(parseBoolean(eh_mobiliada));
    }

    if (searchTerm) {
      const term = `%${searchTerm}%`;
      whereClauses.push('(p.title LIKE ? OR p.city LIKE ? OR p.address LIKE ? OR p.bairro LIKE ? )');
      params.push(term, term, term, term);
    }

    const where = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';

    const allowedSortColumns: Record<string, string> = {
      price: priceColumn,
      created_at: 'p.created_at',
      area_construida: 'p.area_construida',
    };

    const sortColumn = allowedSortColumns[String(sortBy ?? '').toLowerCase()] ?? 'p.created_at';
    const sortDirection = String(order ?? 'DESC').toUpperCase() === 'ASC' ? 'ASC' : 'DESC';

    try {
      const [rows] = await connection.query<PropertyAggregateRow[]>(
        `
          SELECT
            p.*,
            COALESCE(p.promo_percentage, p.promotion_percentage) AS promo_percentage_resolved,
            COALESCE(p.promo_start_date, DATE(p.promotion_start)) AS promo_start_date_resolved,
            COALESCE(p.promo_end_date, DATE(p.promotion_end)) AS promo_end_date_resolved,
            ANY_VALUE(a.id) AS agency_id,
            ANY_VALUE(a.name) AS agency_name,
            ANY_VALUE(a.logo_url) AS agency_logo_url,
            ANY_VALUE(a.address) AS agency_address,
            ANY_VALUE(a.city) AS agency_city,
            ANY_VALUE(a.state) AS agency_state,
            ANY_VALUE(a.phone) AS agency_phone,
            ANY_VALUE(COALESCE(u.name, u_owner.name)) AS broker_name,
            ANY_VALUE(COALESCE(u.phone, u_owner.phone)) AS broker_phone,
            ANY_VALUE(COALESCE(u.email, u_owner.email)) AS broker_email,
            GROUP_CONCAT(DISTINCT pi.image_url ORDER BY pi.id) AS images
          FROM properties p
          LEFT JOIN brokers b ON p.broker_id = b.id
          LEFT JOIN users u ON u.id = b.id
          LEFT JOIN users u_owner ON u_owner.id = p.owner_id
          LEFT JOIN agencies a ON b.agency_id = a.id
          LEFT JOIN property_images pi ON pi.property_id = p.id
          ${where}
          GROUP BY p.id
          ORDER BY ${sortColumn} ${sortDirection}
          LIMIT ? OFFSET ?
        `,
        [...params, numericLimit, offset]
      );

      const [totalRows] = await connection.query<RowDataPacket[]>(
        `SELECT COUNT(DISTINCT p.id) AS total FROM properties p ${where}`,
        params
      );

      const total = totalRows[0]?.total ?? 0;

      return res.json({
        properties: rows.map(row => mapProperty(row, false)),
        total,
        page: numericPage,
        totalPages: Math.ceil(total / numericLimit),
      });
    } catch (error: any) {
      console.error('Erro ao listar imóveis:', error);
      const code = error?.code as string | undefined;
      if (code === 'ECONNREFUSED' || code === 'ENOTFOUND' || code === 'PROTOCOL_CONNECTION_LOST') {
        return res
          .status(503)
          .json({ error: 'Banco de dados indisponível. Tente novamente em instantes.' });
      }
      return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
  }
  async listFeaturedProperties(req: Request, res: Response) {
    const limit = Math.min(Math.max(Number(req.query.limit) || 20, 1), 20);
    const page = Math.max(Number(req.query.page) || 1, 1);
    const offset = (page - 1) * limit;

    try {
      const [rows] = await connection.query<PropertyAggregateRow[]>(
        `
          SELECT
            p.*,
            COALESCE(p.promo_percentage, p.promotion_percentage) AS promo_percentage_resolved,
            COALESCE(p.promo_start_date, DATE(p.promotion_start)) AS promo_start_date_resolved,
            COALESCE(p.promo_end_date, DATE(p.promotion_end)) AS promo_end_date_resolved,
            ANY_VALUE(a.id) AS agency_id,
            ANY_VALUE(a.name) AS agency_name,
            ANY_VALUE(a.logo_url) AS agency_logo_url,
            ANY_VALUE(a.address) AS agency_address,
            ANY_VALUE(a.city) AS agency_city,
            ANY_VALUE(a.state) AS agency_state,
            ANY_VALUE(a.phone) AS agency_phone,
            ANY_VALUE(COALESCE(u.name, u_owner.name)) AS broker_name,
            ANY_VALUE(COALESCE(u.phone, u_owner.phone)) AS broker_phone,
            ANY_VALUE(COALESCE(u.email, u_owner.email)) AS broker_email,
            GROUP_CONCAT(DISTINCT pi.image_url ORDER BY pi.id) AS images
          FROM featured_properties fp
          JOIN properties p ON p.id = fp.property_id
          LEFT JOIN brokers b ON p.broker_id = b.id
          LEFT JOIN users u ON u.id = b.id
          LEFT JOIN users u_owner ON u_owner.id = p.owner_id
          LEFT JOIN agencies a ON b.agency_id = a.id
          LEFT JOIN property_images pi ON pi.property_id = p.id
          WHERE p.status = 'approved'
            AND COALESCE(p.visibility, 'PUBLIC') = 'PUBLIC'
          GROUP BY p.id, fp.position
          ORDER BY fp.position ASC
          LIMIT ? OFFSET ?
        `,
        [limit, offset]
      );

      const [countRows] = await connection.query<RowDataPacket[]>(
        `
          SELECT COUNT(*) AS total
          FROM featured_properties fp
          JOIN properties p ON p.id = fp.property_id
          WHERE p.status = 'approved'
            AND COALESCE(p.visibility, 'PUBLIC') = 'PUBLIC'
        `
      );

      const total = countRows[0]?.total ?? 0;

      return res.json({
        properties: rows.map(row => mapProperty(row, false)),
        total,
        page,
        totalPages: Math.ceil(total / limit),
      });
    } catch (error) {
      console.error('Erro ao listar destaques:', error);
      return res.status(500).json({ error: 'Ocorreu um erro inesperado no servidor.' });
    }
  }

}

export const propertyController = new PropertyController();

